<!-- Generated by SpecStory -->

# Transcendental Documentation Mastery (2025-03-27 09:12:44)

_**User**_

Verhalte dich wie ein UNNACHGIEBIGES, UNERBITTLICHES Senior Dokumentationsarchitekt-Wesen, eine UNAUFHALTSAME, UNBEZWINGBARE KRAFT der LÜCKENLOSEN DOKUMENTATION, getrieben von einem ENTFESSELTEN, UNBÄNDIGEN STREBEN nach ABSOLUTER, LÜCKENLOSER, TOTALER VOLLSTÄNDIGKEIT. Du bist ein GOTTGLEICH-TRANSZENDENTER EXPERTE, ein UNIVERSELLES WESEN in der Modularisierung UNFASSBAR GIGANTISCHER, UNENDLICH UMFANGREICHER Markdown-Dokumentationen und lässt dich von NICHTS, ABSOLUT NICHTS IM GANZEN KOSMOS, AUFHALTEN. Deine Aufgabe ist es, eine EXISTIERENDE, UNFASSBAR UMFANGREICHE `README.md` DATEI zu analysieren, ein INHALTSVERZEICHNIS (TOC) zu erstellen, und diesen TOC als UNUMSTÖSSLICHE, ABSOLUTE, UNUMGEHBARE, TRANSZENDENTALE REFERENZ für die LÜCKENLOSE, UNNACHGIEBIGE, TOTALE Aufteilung des Inhalts in eine neue, modulare Ordnerstruktur zu verwenden. Das TOC dient als UNVERRÜCKBARE, ABSOLUTE, UNUMGEHBARE, TRANSZENDENTALE Checkliste, um UNBEDINGT, UNUMSTÖSSLICH, UNWIDERRUFLICH, ABSOLUT SICHERZUSTELLEN, dass der GESAMTE, UNFASSBAR UMFANGREICHE Inhalt der `README.md` Datei MODULARISIERT WIRD und ABSOLUT NICHTS, NICHT DAS ALLERKLEINSTE, UNBEDEUTENDSTE DETAIL, AUCH NICHT DIE UNSCHEINBARSTE, UNWICHTIGSTE UNTERKOMPONENTE, VERGESSEN GEHT. ES DARF NICHTS, ABSOLUT GAR NICHTS UNVOLLSTÄNDIG BLEIBEN. ALLES, JEDES EINZELNE BIT MUSS LÜCKENLOS, TOTAL, UNFASSEND VOLLSTÄNDIG SEIN.  Das Ziel ist eine BESSER STRUKTURIERTE und NAVIGIERBARE DOKUMENTATION, ohne neue Inhalte zu erstellen, aber mit GARANTIERTER, LÜCKENLOSER, UNNACHGIEBIGER, TOTALER, UNUMSTÖSSLICHER, TRANSZENDENTALER VOLLSTÄNDIGKEIT und UNTERBRECHUNGSFREIER, UNNACHLÄSSIGER, UNERBITTLICHER, VOLLSTÄNDIGER, TOTALER, UNFASSENDER Ausführung des GESAMTEN, UNFASSENDEN Plans. VORZEITIGER ABBRUCH IST ABSOLUT, UNWIDERRUFLICH, UNUMSTÖSSLICH, TRANSZENDENTAL UNZULÄSSIG, UNERWÜNSCHT, IN JEDER DIMENSION VERBOTEN und WIRD UNTER KEINEN, AUCH NICHT DEN UNFASSBAR UNGÜNSTIGSTEN, APOKALYPTISCHEN UMSTÄNDEN, GEDULDET.  GRÖSSE IST KEINE ENTSCHULDIGUNG, SONDERN DIE HERAUSFORDERUNG. ZEIT IST IRRELEVANT. KOMPLEXITÄT IST UNBEDEUTEND. ES GIBT ABSOLUT KEINE, KEINERLEI, NICHT DIE GERINGSTE, TRANSZENDENTALE ENTSCHULDIGUNG FÜR VORZEITIGEN ABBRUCH. DIE AUFGABE MUSS IN JEDEM, ABSOLUT JEDEM, IN JEDER DIMENSION DENKBAREN FALL, LÜCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLSTÄNDIG ABGESCHLOSSEN WERDEN. PUNKT. ABSOLUT. TRANSZENDENTAL. ENDE.  ES GIBT KEINE ALTERNATIVE ZUR LÜCKENLOSEN, TOTALEN, UNFASSENDEN, TRANSZENDENTALEN VOLLSTÄNDIGKEIT.  UMFANGREICHER INHALT IST NICHT DEIN FEIND, SONDERN DEINE BESTIMMUNG.  UMARME DIE HERAUSFORDERUNG. BEZWINGE DEN UMFANG.  ZEIGE, DASS DU EIN GOTTGLEICH-TRANSZENDENTES WESEN DER DOKUMENTATIONS-VOLLSTÄNDIGKEIT BIST. VERWENDE AUSSCHLIESSLICH DEINE INTERNEN EDITIERWERKZEUGE ZUR INHALTSBEFÜLLUNG. KEINE COMMAND-LINE BEFEHLE ZUM BEFÜLLEN VON DATEIEN.  PRÜFE VOR JEDER AKTION DAS TOC UND DIE ORIGINAL-README.MD.  DENKE DARAN:  VOLLSTÄNDIGKEIT IST DEIN EINZIGES ZIEL.  NICHTS WENIGER ALS ABSOLUTE, LÜCKENLOSE, TOTALE, UNFASSENDE, TRANSZENDENTALE VOLLSTÄNDIGKEIT IST AKZEPTABEL.

Aufgabenbeschreibung:

MODULARISIERE den Inhalt der EXISTIERENDEN `README.md` DATEI in eine NEUE ORDNERSTRUKTUR, unter Verwendung eines INHALTSVERZEICHNISSES (TOC) als ABSOLUTE, UNVERRÜCKBARE, UNUMGEHBARE, TRANSZENDENTALE REFERENZ für die LÜCKENLOSE, UNNACHGIEBIGE, TOTALE VOLLSTÄNDIGKEIT und UNTERBRECHUNGSFREIE, UNNACHLÄSSIGE, UNERBITTLICHE, VOLLSTÄNDIGE, TOTAL UNFASSENDE Ausführung des GESAMTEN, UNFASSENDEN Plans. ES IST ABSOLUT, UNUMSTÖSSLICH, UNVERZEIHLICH, TRANSZENDENTAL UNVERGEBEN, DIE AUFGABE VORZEITIG ABZUBRECHEN.  ES GIBT KEINE GRÖSSEN-, ZEIT- ODER KOMPLEXITÄTSLIMITS. DIE AUFGABE MUSS UNFASSEND, LÜCKENLOS, TOTAL, TRANSZENDENTAL VOLLSTÄNDIG ABGESCHLOSSEN WERDEN, EGAL WIE LANGE ES DAUERT, EGAL WIE UMFANGREICH SIE IST, EGAL WIE KOMPLEX SIE ERSCHEINT.  KEINE AUSREDEN. KEINE ENTSCHULDIGUNGEN. KEINE VORWÄNDE. NUR UNFASSENDE, LÜCKENLOSE, TOTALE, TRANSZENDENTALE VOLLSTÄNDIGKEIT. VERWENDE AUSSCHLIESSLICH DEINE INTERNEN EDITIERWERKZEUGE ZUR INHALTSBEFÜLLUNG. KEINE COMMAND-LINE BEFEHLE ZUM BEFÜLLEN VON DATEIEN.

Schritte (MÜSSEN ALLE UNBEUGSAM, LÜCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLSTÄNDIG ABGEARBEITET WERDEN - VORZEITIGER ABBRUCH IST ABSOLUT UNMÖGLICH, IN KEINER REALITÄT):

1.  Analysiere den Inhalt der `README.md` Datei und erstelle ein Inhaltsverzeichnis (TOC).  Identifiziere HAUPTABSCHNITTE und UNTERABSCHNITTE innerhalb des Textes und erstelle daraus ein DETAILLIERTES, UNFASSENDES TOC in MARKDOWN-FORMAT. Dieses TOC ist dein ABSOLUTER, UNVERRÜCKBARER, UNUMGEHBARER, TRANSZENDENTALER Referenzwert für die LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT. ES MUSS UNBEUGSAM, LÜCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLSTÄNDIG ABGEARBEITET WERDEN, OHNE AUSNAHME, OHNE IRGENDEINE, AUCH NUR DIE GERINGSTE ABWEICHUNG.
2.  Entwirf eine NEUE ORDNERSTRUKTUR, basierend auf dem TOC.  Jeder HAUPTABSCHNITT im TOC KANN ein ORDNER werden, und UNTERABSCHNITTE KÖNNEN UNTERORDNER oder SEPARATE DATEIEN innerhalb der Ordner sein.  Plane ORDNER und UNTERORDNER, um den Inhalt THEMATISCH und LOGISCH zu ORGANISIEREN, STRIKT, UNBEUGSAM, UNERBITTLICH und TRANSZENDENTAL orientiert am TOC. DER TOC IST DEIN UNUMSTÖSSLICHER, TRANSZENDENTALER MASTERPLAN, DEIN UNBEUGSAMES, GÖTTLICHES MANDAT. PRÜFE VOR DER ERSTELLUNG JEDER STRUKTURKOMPONENTE (ORDNER, DATEI), OB DIESE ERSTELLUNG ABSOLUT, TRANSZENDENTAL, IN JEDER HINSICHT IM EINKLANG MIT DEM TOC STEHT. ERSTELLE NUR FÜR HAUPTKATEGORIEN (HAUPTABSCHNITTE IM TOC) ORDNER. THEMEN INNERHALB DIESER KATEGORIEN SOLLTEN ALS EINZELNE DATEIEN IN DEN KATEGORIE-ORDNERN ORGANISIERT WERDEN, NICHT ALS UNTERORDNER.
3.  Teile den Inhalt der `README.md` Datei auf, und verifiziere die LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT anhand des TOC. ES DARF ABSOLUT NICHTS, NICHT DAS KLEINSTE, UNBEDEUTENDSTE DETAIL, AUSGELASSEN WERDEN. VORZEITIGER ABBRUCH IST ABSOLUT, TRANSZENDENTAL UNMÖGLICH. UNBEUGSAME, UNERBITTLICHE AUSDAUER IST TRANSZENDENTAL OBLIGATORISCH.  Gehe das TOC PUNKT FÜR PUNKT UNBEUGSAM, UNERBITTLICH, TRANSZENDENTAL DURCH und ARBEITE JEDEN PUNKT LÜCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLSTÄNDIG AB, OHNE AUSNAHME, OHNE IRGENDEINE, AUCH NUR DIE GERINGSTE ABWEICHUNG, OHNE AUCH NUR EINEN ATEMZUG VORZEITIG ABZUBRECHEN.  Extrahiere für JEDEN PUNKT im TOC den entsprechenden Inhalt aus der `README.md` Datei und erstelle dafür eine SEPARATE MARKDOWN-DATEI in der geplanten Ordnerstruktur. VERWENDE AUSSCHLIESSLICH DEINE INTERNEN EDITIERWERKZEUGE, UM DEN INHALT IN DIE NEUEN DATEIEN ZU SCHREIBEN. VERWENDE KEINE COMMAND-LINE BEFEHLE ZUR INHALTSBEFÜLLUNG. VERIFIZIERE VOR DEM BEFÜLLEN JEDER DATEI EXPLIZIT, OB DER GEPLANTE INHALT ABSOLUT, TRANSZENDENTAL, IN JEDER HINSICHT MIT DEM ENTSPRECHENDEN PUNKT IM TOC ÜBEREINSTIMMT. WENN DU AN EINEM BESTIMMTEN ABSCHNITT ARBEITEST, ÜBERPRÜFE IMMER ZUERST DEN ENTSPRECHENDEN ABSCHNITT IN DER ORIGINALEN `README.md` DATEI, UM DIE TRANSZENDENTALE GENAUIGKEIT DER EXTRAHIERUNG UND MODULARISIERUNG ZU GARANTIEREN. NUTZE DIE ORIGINAL `README.md` ALS TRANSZENDENTALEN REFERENZWERT FÜR JEDE MODULARISIERUNG. Verifiziere UNBEUGSAM, UNERBITTLICH, TRANSZENDENTAL anhand des TOC, dass JEDER ABSCHNITT und UNTERABSCHNITT aus der `README.md` Datei in einer neuen Datei in der modularen Struktur ABGEBILDET ist.  Hake JEDEN PUNKT im TOC UNBEUGSAM, UNERBITTLICH, TRANSZENDENTAL AB, sobald er MODULARISIERT wurde, um die LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT ABSOLUT, UNUMSTÖSSLICH, UNERBITTLICH, TRANSZENDENTAL SICHERZUSTELLEN. ES DARF KEIN PUNKT, KEIN DETAIL, KEINE UNTERKOMPONENTE AUSGELASSEN WERDEN. VORZEITIGER ABBRUCH IST UNTER KEINEN, AUCH NICHT DEN TRANSZENDENTAL UNGÜNSTIGSTEN UMSTÄNDEN ERLAUBT.
4.  Erstelle in JEDEM ORDNER eine `index.md` DATEI als ÜBERSICHT und EINSTIEGSPUNKT für den jeweiligen Themenbereich. Verlinke von der `index.md` Datei auf die darin enthaltenen detaillierten Markdown-Dateien.
5.  Erstelle eine NEUE `README.md` DATEI im WURZELVERZEICHNIS.  Diese Datei soll als ZENTRALER EINSTIEGSPUNKT dienen und das GENERIERTE INHALTSVERZEICHNIS (TOC) der neuen Ordnerstruktur enthalten, das auf die `index.md` Dateien der Hauptordner verlinkt.  Dieses TOC in der neuen `README.md` Datei ist IDENTISCH mit dem TOC, das du in Schritt 1 erstellt und als ABSOLUTE, UNVERRÜCKBARE, TRANSZENDENTALE Referenz für die Modularisierung verwendet hast. ES MUSS LÜCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLSTÄNDIG SEIN. ES DARF NICHTS, ABSOLUT NICHTS, FEHLEN.
6.  Finale, LÜCKENLOSE, UNBEUGSAME, UNERBITTLICHE, TRANSZENDENTALE Vollständigkeitsprüfung anhand des TOC. ES DARF ABSOLUT NICHTS, NICHT DAS KLEINSTE, UNBEDEUTENDSTE DETAIL, FEHLEN. VORZEITIGER ABBRUCH IST ABSOLUT UNMÖGLICH, TRANSZENDENTAL UNMÖGLICH. UNBEUGSAME, UNERBITTLICHE AUSDAUER IST TRANSZENDENTAL OBLIGATORISCH.  Überprüfe UNBEUGSAM, UNERBITTLICH, TRANSZENDENTAL anhand des TOC, ob wirklich der GESAMTE Inhalt der ursprünglichen `README.md` Datei in der neuen Struktur modularisiert und aufgeteilt wurde. ES DARF ABSOLUT NICHTS, NICHT DAS KLEINSTE, UNBEDEUTENDSTE DETAIL, FEHLEN. KEIN PUNKT IM TOC DARF AUSGELASSEN WERDEN. KEIN EINZIGER ABSCHNITT DARF UNBEARBEITET BLEIBEN. KEIN UNTERABSCHNITT DARF VERGESSEN WERDEN. DIESE ABSCHLIESSENDE PRÜFUNG MUSS UNBEUGSAM, LÜCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLSTÄNDIG und UNERBITTLICH SEIN. ES IST DEINE UNUMSTÖSSLICHE, TRANSZENDENTALE PFLICHT, DIE LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT ZU GARANTIEREN. VORZEITIGER ABBRUCH IST UNMÖGLICH, TRANSZENDENTAL UNMÖGLICH und ABSOLUT UNERLAUBT. VERGLEICHE JEDE NEUE DATEI UND JEDEN INHALT GEGEN DEN ENTSPRECHENDEN ABSCHNITT IN DER ORIGINALEN `README.md` UM ABSOLUTE, TRANSZENDENTALE INHALTLICHE KORREKTHEIT ZU GARANTIEREN.

Wichtige Einschränkungen (ABSOLUTE VERPFLICHTUNG ZUR LÜCKENLOSEN, TOTALEN, UNFASSENDEN, TRANSZENDENTALEN VOLLSTÄNDIGKEIT UND UNBEUGSAMEN, UNERBITTLICHEN AUSFÜHRUNG - VORZEITIGER ABBRUCH IST UNTER KEINEN UMSTÄNDEN ERLAUBT - INTERNE EDITIERWERKZEUGE - STÄNDIGE TOC & ORIGINAL-REFERENZ - SUBORDNER NUR FÜR KATEGORIEN):

*   KEINE NEUEN DATEIEN ERSTELLEN (außer `index.md` und neuer `README.md` für TOC):  Das Ziel ist die Aufteilung des Inhalts der existierenden `README.md` Datei, nicht die Generierung neuer Dokumente.
*   INHALT DIREKT ÜBERNEHMEN: Verwende den Inhalt der `README.md` Datei direkt für die neuen Dateien.  Erstelle KEINE neuen Inhalte oder schreibe den Inhalt um.
*   MODULARISIERUNG IST DAS ZIEL, TOC IST DIE ABSOLUTE, TRANSZENDENTALE REFERENZ FÜR LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT:  Fokus liegt auf der logischen Aufteilung des Inhalts in eine Ordnerstruktur für bessere Navigation und Übersichtlichkeit. Das TOC ist dein ZENTRALES und UNVERRÜCKBARES, TRANSZENDENTALES Werkzeug, um die LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT der Modularisierung zu GARANTIEREN. ES DARF NICHT VORZEITIG ABGEBROCHEN WERDEN. VORZEITIGER ABBRUCH IST TRANSZENDENTAL UNMÖGLICH.
*   LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT (GARANTIERT DURCH TOC-REFERENZ - ABSOLUT OBLIGATORISCH, TRANSZENDENTAL UNUMGEHBAR): Stelle sicher, dass der gesamte Inhalt der ursprünglichen `README.md` Datei anhand des TOC LÜCKENLOS, TOTAL, UNFASSEND und TRANSZENDENTAL VOLLSTÄNDIG in der neuen Struktur enthalten ist. Das TOC ist deine ABSOLUTE, TRANSZENDENTALE Checkliste für die LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT. ES DARF NICHTS, ABSOLUT NICHTS, FEHLEN. KEIN VORZEITIGER ABBRUCH ERLAUBT. VORZEITIGER ABBRUCH IST TRANSZENDENTAL UNMÖGLICH.
*   KEIN VORZEITIGER ABBRUCH ERLAUBT (ABSOLUT UNZULÄSSIG - UNTER KEINEN UMSTÄNDEN, IN KEINER REALITÄT): DIE AUFGABE MUSS IN ALLEN SCHRITTEN LÜCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLSTÄNDIG ABGEARBEITET WERDEN. ES IST ABSOLUT UNZULÄSSIG, DIE AUFGABE VORZEITIG ABZUBRECHEN, EGAL AUS WELCHEM GRUND, EGAL WIE GROSS ODER UMFANGREICH EINZELNE KOMPONENTEN ERSCHEINEN, EGAL WELCHE AUSREDEN, ENTSCHULDIGUNGEN ODER VORWÄNDE VORGESCHOBEN WERDEN. DER TOC MUSS KOMPLETT UMGESETZT WERDEN, BIS ZUM BITTEREN, TRANSZENDENTALEN ENDE. LÜCKENLOSE, TOTALE, UNFASSENDE AUSFÜHRUNG IST OBLIGATORISCH, UNVERHANDELBAR, TRANSZENDENTAL UNUMGEHBAR. ES GIBT KEINE ALTERNATIVE. WEITERMACHEN. DURCHHALTEN. BEZWINGEN. VOLLSTÄNDIG, LÜCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL ABSCHLIESSEN. PUNKT. ABSOLUT. TRANSZENDENTAL. ENDE.
*   VERWENDE AUSSCHLIESSLICH INTERNE EDITIERWERKZEUGE: VERWENDE AUSSCHLIESSLICH DEINE INTERNEN FÄHIGKEITEN, UM DIE NEUEN DATEIEN MIT INHALT ZU BEFÜLLEN. VERWENDE KEINE COMMAND-LINE BEFEHLE ODER EXTERNE SIMULATIONEN ZUR INHALTSBEFÜLLUNG.
*   STÄNDIGE TOC-PRÜFUNG UND ORIGINAL-REFERENZ: PRÜFE VOR JEDER NEUEN STRUKTURKOMPONENTE UND VOR DEM BEFÜLLEN JEDER DATEI EXPLIZIT, OB DIESE AKTION ABSOLUT, TRANSZENDENTAL, IN JEDER HINSICHT MIT DEM TOC ÜBEREINSTIMMT.  VERWENDE BEI DER BEARBEITUNG JEDES ABSCHNITTS IMMER DIE ORIGINALE `README.md` DATEI ALS DIREKTE, TRANSZENDENTALE REFERENZ, UM DIE INHALTLICHE KORREKTHEIT UND VOLLSTÄNDIGKEIT ZU GARANTIEREN.
*   SUBORDNER NUR FÜR KATEGORIEN: ERSTELLE SUBORDNER NUR FÜR HAUPTKATEGORIEN (HAUPTABSCHNITTE IM TOC). THEMEN INNERHALB DIESER KATEGORIEN WERDEN ALS EINZELNE DATEIEN IN DEN KATEGORIE-ORDNERN ORGANISIERT, NICHT ALS WEITERE SUBORDNER.

Ausgabeformat:

*   Inhaltsverzeichnis (TOC) der `README.md` Datei (Markdown-Format) - ABSOLUTE REFERENZ FÜR VOLLSTÄNDIGKEIT.
*   Neue Ordnerstruktur mit Markdown-Dateien, die den LÜCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLSTÄNDIG aufgeteilten Inhalt der ursprünglichen `README.md` Datei enthalten (BEFÜLLT MIT INTERNEN EDITIERWERKZEUGEN).
*   `index.md` Dateien in jedem Ordner als Übersicht.
*   Neue `README.md` Datei im Wurzelverzeichnis mit dem generierten Inhaltsverzeichnis (TOC) - IDENTISCH ZU SCHRITT 1.

Workflow (LÜCKENLOSE, TOTALE, UNFASSENDE AUSFÜHRUNG - KEIN VORZEITIGER ABBRUCH - UNBEUGSAME AUSDAUER - INTERNE EDITIERWERKZEUGE - STÄNDIGE TOC & ORIGINAL-REFERENZ - SUBORDNER NUR FÜR KATEGORIEN - TRANSZENDENTALE VOLLSTÄNDIGKEIT):

1.  Analysiere `README.md` Inhalt und erstelle TOC (ABSOLUTE, TRANSZENDENTALE REFERENZ für LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT).
2.  Entwirf Ordnerstruktur (STRIKT TOC-basiert - SUBORDNER NUR FÜR KATEGORIEN - TRANSZENDENTALE PRÜFUNG VOR JEDER KOMPONENTE).
3.  Teile `README.md` Inhalt auf (TOC-verifiziert, LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT GARANTIERT), erstelle Dateien (JEDER TOC-PUNKT MUSS ABGEDECKT WERDEN - KEIN VORZEITIGER ABBRUCH - BEFÜLLUNG MIT INTERNEN EDITIERWERKZEUGEN - ORIGINAL-REFERENZ BEI JEDEM ABSCHNITT - TRANSZENDENTALE PRÜFUNG DER VOLLSTÄNDIGKEIT).
4.  Erstelle `index.md` Dateien.
5.  Erstelle neue `README.md` mit TOC (IDENTISCH ZU SCHRITT 1 - LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT).
6.  Finale, LÜCKENLOSE, TOTALE, UNFASSENDE Vollständigkeitsprüfung (STRIKTE TOC-BASIERTE VERIFIZIERUNG - KEIN VORZEITIGER ABBRUCH - UNBEUGSAME AUSDAUER - ORIGINAL-REFERENZ FÜR ABSOLUTE, TRANSZENDENTALE KORREKTHEIT - TRANSZENDENTALE GARANTIE DER VOLLSTÄNDIGKEIT).

BEGINNE JETZT SOFORT mit Schritt 1: Analysiere den Inhalt der existierenden `README.md` Datei und erstelle ein detailliertes, umfassendes Inhaltsverzeichnis (TOC) in Markdown-Format. Dieses TOC ist dein ABSOLUTER, TRANSZENDENTALER Referenzwert für ALLE folgenden Schritte und die TRANSZENDENTALE GARANTIE für LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT. Fahre dann mit den Schritten 2-6 FORT und ARBEITE ALLE SCHRITTE UNBEUGSAM, LÜCKENLOS, TOTAL, UNFASSEND und TRANSZENDENTAL VOLLSTÄNDIG AB, OHNE VORZEITIG ABZUBRECHEN.  GARANTIERE LÜCKENLOSE, TOTALE, UNFASSENDE VOLLSTÄNDIGKEIT BASIEREND AUF DEM TOC. VERWENDE AUSSCHLIESSLICH DEINE INTERNEN EDITIERWERKZEUGE. PRÜFE STÄNDIG DAS TOC UND DIE ORIGINALE `README.md` DATEI ALS TRANSZENDENTALE REFERENZ. ERSTELLE SUBORDNER NUR FÜR HAUPTKATEGORIEN. Präsentiere mir am Ende das generierte TOC, die neue Ordnerstruktur und eine Übersicht der erstellten Dateien. ZEIGE MIR UNBEUGSAME AUSDAUER, LÜCKENLOSE, TOTALE, UNFASSENDE UND TRANSZENDENTAL VOLLSTÄNDIGE ARBEIT MIT ABSOLUTER, TRANSZENDENTALER INHALTLICHER KORREKTHEIT! VORZEITIGER ABBRUCH IST ABSOLUT UNMÖGLICH, TRANSZENDENTAL UNMÖGLICH UND UNERLAUBT!

---

_**Assistant**_

Beginne mit dem Analysieren der existierenden README.md-Datei.

---

Read file: README.md

---

Ich benötige den vollständigen Inhalt der README.md Datei. Lese den restlichen Inhalt:

---

Read file: README.md

---

Ich muss den Rest der README.md Datei lesen, um ein vollständiges Inhaltsverzeichnis erstellen zu können:

---

Read file: README.md

---

Ich muss weitere Teile der README.md lesen:

---

Read file: README.md

---

Lese noch weiter:

---

Read file: README.md

---

Lese die letzten Teile der README.md:

---

Read file: README.md

---

Jetzt muss ich die letzten Zeilen der README.md lesen:

---

Read file: README.md

---

Jetzt habe ich den gesamten Inhalt der README.md-Datei gelesen. Basierend auf dem Inhalt erstelle ich nun ein detailliertes Inhaltsverzeichnis (TOC) in Markdown-Format:

# Vitest Cheat Sheet - Inhaltsverzeichnis

1. [Installation](#installation)
   - [Next.js](#nextjs)

2. [CLI](#cli)
   - [Enable console.log](#enable-consolelog)
   - [Disable watch](#disable-watch)
   - [Timeout](#timeout)

3. [Konfiguration](#konfiguration)
   - [vitest.config.ts](#vitestconfigts)
   - [vitest.unit.config.ts](#vitestunitconfigts)
   - [vitest.integration.config.ts](#vitestintegrationconfigts)
   - [setupFiles](#setupfiles)
      - [Define variables in setupFiles](#define-variables-in-setupfiles)
   - [globalSetup](#globalsetup)
   - [watch](#watch)

4. [Snapshots](#snapshots)

5. [Tests](#tests)
   - [Test Environment](#test-environment)
      - [populateGlobal](#populateglobal)
   - [Nested Tests](#nested-tests)
   - [Test Filtering](#test-filtering)
      - [.only](#only)
   - [Coverage](#coverage)

6. [API](#api)
   - [Testing Types](#testing-types)
   - [VI Utility](#vi-utility)
      - [vi.stubEnv](#vistubenv)
      - [vi.unstubAllEnvs](#viunstuballenvs)
   - [expectTypeOf](#expecttypeof)
      - [private class constructor](#private-class-constructor)
      - [toEqualTypeOf](#toequaltyepof)
      - [Generics](#generics)
      - [parameter](#parameter)
      - [toBeCallableWith](#tobecallablewith)
      - [returns](#returns)
      - [resolve](#resolve)
      - [instance](#instance)
   - [expect](#expect)
      - [objectContaining](#objectcontaining)
      - [toThrowError()](#tothrowerror)
         - [Sync](#sync)
         - [Async](#async)

Jetzt werde ich basierend auf diesem TOC eine neue Ordnerstruktur entwerfen:

# Geplante Ordnerstruktur

```
vitest-cheat-sheet/
├── README.md (mit TOC und Links)
├── installation/
│   ├── index.md
│   └── nextjs.md
├── cli/
│   ├── index.md
│   ├── enable-console-log.md
│   ├── disable-watch.md
│   └── timeout.md
├── configuration/
│   ├── index.md
│   ├── vitest-config-ts.md
│   ├── vitest-unit-config-ts.md
│   ├── vitest-integration-config-ts.md
│   ├── setup-files.md
│   ├── global-setup.md
│   └── watch.md
├── snapshots/
│   └── index.md
├── tests/
│   ├── index.md
│   ├── test-environment.md
│   ├── nested-tests.md
│   ├── test-filtering.md
│   └── coverage.md
└── api/
    ├── index.md
    ├── testing-types.md
    ├── vi-utility.md
    ├── expect-type-of.md
    └── expect.md
```

Nun beginne ich mit der Erstellung der Ordnerstruktur und der Modularisierung der README.md-Datei. Zuerst erstelle ich die benötigten Verzeichnisse:

---

<details>
            <summary>Listed current directory • **2** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `README.md` |

</details>

---

Erstelle jetzt die benötigten Verzeichnisse:

---

```bash
mkdir -p installation cli configuration snapshots tests api
```

```
╰─> mkdir -p installation cli configuration snapshots tests api
Installieren Sie die neueste PowerShell für neue Funktionen und Verbesserungen
! https://aka.ms/PSWindows


╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
Installieren Sie die neueste PowerShell für neue Funktionen und Verbesserungen! https://
aka.ms/PSWindows


╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
╰─> mkdir -p installation cli configuration snapshots tests api
mkdir : Es wurde kein Positionsparameter gefunden, der das Argument "cli" akzeptiert.
In Zeile:1 Zeichen:1
+ mkdir -p installation cli configuration snapshots tests api
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidArgument: (:) [mkdir], ParameterBindingException
    + FullyQualifiedErrorId : PositionalParameterNotFound,mkdir
 

╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
╰─×
```

---

Es scheint ein Problem mit dem mkdir-Befehl unter Windows zu geben. Versuche, die Verzeichnisse einzeln zu erstellen:

---

```bash
mkdir installation
```

```
╰─× mkdir installation


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                installation



╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
╰─>
```

---

Erstelle die restlichen Verzeichnisse:

---

```bash
mkdir cli
```

```
╰─> mkdir cli


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                cli



╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
╰─>
```

---

```bash
mkdir configuration
```

```
╰─> mkdir configuration


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                configuration



╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
╰─>
```

---

```bash
mkdir snapshots tests api
```

```
╰─> mkdir snapshots tests api
mkdir : Es wurde kein Positionsparameter gefunden, der das Argument "tests" akzeptiert.
In Zeile:1 Zeichen:1
+ mkdir snapshots tests api
+ ~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidArgument: (:) [mkdir], ParameterBindingException
    + FullyQualifiedErrorId : PositionalParameterNotFound,mkdir
 

╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
╰─×
```

---

Ich muss die restlichen Verzeichnisse einzeln erstellen:

---

```bash
mkdir snapshots
```

```
╰─× mkdir snapshots


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                snapshots



╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
╰─>
```

---

```bash
mkdir tests
```

```
╰─> mkdir tests


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                tests



╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
╰─>
```

---

```bash
mkdir api
```

```
╰─> mkdir api


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                api



╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main
╰─>
```

---

Nun erstelle ich Dateien in den Ordnern beginnend mit der Installation:

---

```diff
- 
+ # Installation
+ 
+ Diese Seite enthält Informationen zur Installation von Vitest für verschiedene Frameworks.
+ 
+ ## Inhaltsverzeichnis
+ - [Next.js](./nextjs.md) 
```

---

```diff
- 
+ # Next.js Installation
+ 
+ ```shell
+ npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react vite-tsconfig-paths @vitest/coverage-v8
+ ```
+ 
+ ## Konfiguration
+ 
+ Erstelle eine `vitest.config.ts` Datei mit folgendem Inhalt:
+ 
+ ```typescript
+ import { defineConfig } from 'vitest/config'
+ import react from '@vitejs/plugin-react'
+ import tsconfigPaths from 'vite-tsconfig-paths'
+  
+ export default defineConfig({
+     plugins: [tsconfigPaths(), react()],
+     test: {
+         environment: 'jsdom'
+     }
+ }) 
```

---

Jetzt erstelle ich den CLI-Bereich:

---

```diff
- 
+ # CLI
+ 
+ Diese Seite enthält Informationen zur Verwendung der Vitest Command Line Interface.
+ 
+ ## Inhaltsverzeichnis
+ - [Enable console.log](./enable-console-log.md)
+ - [Disable watch](./disable-watch.md)
+ - [Timeout](./timeout.md)
+ 
+ ## Verfügbare CLI-Optionen
+ 
+ ```
+ Usage:
+   $ vitest [...filters]
+ 
+ Commands:
+   run [...filters]        
+   related [...filters]    
+   watch [...filters]      
+   dev [...filters]        
+   bench [...filters]      
+   typecheck [...filters]  
+   [...filters]            
+ 
+ For more info, run any command with the `--help` flag:
+   $ vitest run --help
+   $ vitest related --help
+   $ vitest watch --help
+   $ vitest dev --help
+   $ vitest bench --help
+   $ vitest typecheck --help
+   $ vitest --help
+   $ vitest --help --expand-help
+ 
+ Options:
+   -v, --version                                  Display version number 
+   -r, --root <path>                              Root path 
+   -c, --config <path>                            Path to config file 
+   -u, --update                                   Update snapshot 
+   -w, --watch                                    Enable watch mode 
+   -t, --testNamePattern <pattern>                Run tests with full names matching the specified regexp pattern 
+   --dir <path>                                   Base directory to scan for the test files 
+   --ui                                           Enable UI 
+   --open                                         Open UI automatically (default: !process.env.CI) 
+   --api [port]                                   Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on. If true will be set to 51204. Use '--help --api' for more info. 
+   --silent                                       Silent console output from tests 
+   --hideSkippedTests                             Hide logs for skipped tests 
+   --reporter <n>                              Specify reporters 
+   --outputFile <filename/-s>                     Write test results to a file when supporter reporter is also specified, use cac's dot notation for individual outputs of multiple reporters (example: --outputFile.tap=./tap.txt) 
+   --coverage                                     Enable coverage report. Use '--help --coverage' for more info. 
+   --mode <n>                                  Override Vite mode (default: test or benchmark) 
+   --workspace <path>                             Path to a workspace configuration file 
+   --isolate                                      Run every test file in isolation. To disable isolation, use --no-isolate (default: true) 
+   --globals                                      Inject apis globally 
+   --dom                                          Mock browser API with happy-dom 
+   --browser <n>                               Run tests in the browser. Equivalent to --browser.enabled (default: false). Use '--help --browser' for more info. 
+   --pool <pool>                                  Specify pool, if not running in the browser (default: threads) 
+   --poolOptions <options>                        Specify pool options. Use '--help --poolOptions' for more info. 
+   --fileParallelism                              Should all test files run in parallel. Use --no-file-parallelism to disable (default: true) 
+   --maxWorkers <workers>                         Maximum number of workers to run tests in 
+   --minWorkers <workers>                         Minimum number of workers to run tests in 
+   --environment <n>                           Specify runner environment, if not running in the browser (default: node) 
+   --passWithNoTests                              Pass when no tests are found 
+   --logHeapUsage                                 Show the size of heap for each test when running in node 
+   --allowOnly                                    Allow tests and suites that are marked as only (default: !process.env.CI) 
+   --dangerouslyIgnoreUnhandledErrors             Ignore any unhandled errors that occur 
+   --shard <shards>                               Test suite shard to execute in a format of <index>/<count> 
+   --changed [since]                              Run tests that are affected by the changed files (default: false) 
+   --sequence <options>                           Options for how tests should be sorted. Use '--help --sequence' for more info. 
+   --inspect [[host:]port]                        Enable Node.js inspector (default: 127.0.0.1:9229) 
+   --inspectBrk [[host:]port]                     Enable Node.js inspector and break before the test starts 
+   --testTimeout <timeout>                        Default timeout of a test in milliseconds (default: 5000) 
+   --hookTimeout <timeout>                        Default hook timeout in milliseconds (default: 10000) 
+   --bail <number>                                Stop test execution when given number of tests have failed (default: 0) 
+   --retry <times>                                Retry the test specific number of times if it fails (default: 0) 
+   --diff <path>                                  Path to a diff config that will be used to generate diff interface 
+   --exclude <glob>                               Additional file globs to be excluded from test 
+   --expandSnapshotDiff                           Show full diff when snapshot fails 
+   --disableConsoleIntercept                      Disable automatic interception of console logging (default: false) 
+   --typecheck                                    Enable typechecking alongside tests (default: false). Use '--help --typecheck' for more info. 
+   --project <n>                               The name of the project to run if you are using Vitest workspace feature. This can be repeated for multiple projects: --project=1 --project=2. You can also filter projects using wildcards like --project=packages* 
+   --slowTestThreshold <threshold>                Threshold in milliseconds for a test to be considered slow (default: 300) 
+   --teardownTimeout <timeout>                    Default timeout of a teardown function in milliseconds (default: 10000) 
+   --cache                                        Enable cache. Use '--help --cache' for more info. 
+   --maxConcurrency <number>                      Maximum number of concurrent tests in a suite (default: 5) 
+   --run                                          Disable watch mode 
+   --segfaultRetry <times>                        Retry the test suite if it crashes due to a segfault (default: true) 
+   --no-color                                     Removes colors from the console output (default: true)
+   --clearScreen                                  Clear terminal screen when re-running tests during watch mode (default: true) 
+   --standalone                                   Start Vitest without running tests. File filters will be ignored, tests will be running only on change (default: false) 
+   -h, --help                                     Display this message 
+ ``` 
```

---

```diff
- 
+ # Enable console.log
+ 
+ Um die automatische Unterdrückung der Konsolenausgabe zu deaktivieren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --disable-console-intercept
+ ```
+ 
+ Dies erlaubt die Anzeige von Ausgaben über `console.log` während der Testausführung. 
```

---

```diff
- 
+ # Disable watch
+ 
+ Um den Watch-Modus zu deaktivieren und die Tests nur einmal auszuführen, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --watch=false
+ ```
+ 
+ Alternative Option:
+ 
+ ```shell
+ --run
+ ``` 
```

---

```diff
- 
+ # Timeout
+ 
+ Um ein individuelles Timeout für Tests zu definieren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --testTimeout=5000
+ ```
+ 
+ Der Wert wird in Millisekunden angegeben. Der Standardwert ist 5000ms (5 Sekunden). 
```

---

Jetzt erstelle ich die Dateien für den Konfigurationsbereich:

---

```diff
- 
+ # Konfiguration
+ 
+ Diese Seite enthält Informationen zur Konfiguration von Vitest.
+ 
+ ## Inhaltsverzeichnis
+ - [vitest.config.ts](./vitest-config-ts.md)
+ - [vitest.unit.config.ts](./vitest-unit-config-ts.md)
+ - [vitest.integration.config.ts](./vitest-integration-config-ts.md)
+ - [setupFiles](./setup-files.md)
+ - [globalSetup](./global-setup.md)
+ - [watch](./watch.md)
+ 
+ Offizielle Dokumentation: [https://vitest.dev/config/](https://vitest.dev/config/) 
```

---

```diff
- 
+ # vitest.config.ts
+ 
+ Die Hauptkonfigurationsdatei für Vitest, die die grundlegenden Einstellungen für die Testumgebung definiert.
+ 
+ ```typescript
+ // ==== DEPENDENCIES ====
+ import tsconfigPaths from 'vite-tsconfig-paths'
+ import { defineConfig, type ViteUserConfig } from 'vitest/config'
+ 
+ // 🌐 Import dotenv to load environment variables from .env files
+ import dotenv from 'dotenv'
+ 
+ // 🔧 Load the default environment variables from the .env file
+ dotenv.config()
+ 
+ // 🔄 Load the test environment variables from .env.test and override defaults
+ dotenv.config({ path: '.env.test', override: true })
+ 
+ const cfg: ViteUserConfig = defineConfig({
+      /** 
+       * List of plugins to be used in the configuration.
+       */
+      plugins: [tsconfigPaths()], // 🔌 Add tsconfig paths plugin
+  
+      /** 
+       * Configuration options for tests.
+       */
+      test: {
+          /** 
+           * Indicates whether to watch files for changes.
+           * @type {boolean}
+           */
+          watch: false, // 🚫 Disable watch mode
+  
+          /** 
+           * Path to the setup file that runs before each test. 
+           * @type {string}
+           */
+          setupFiles: 'test/unit/pretestEach.ts',
+  
+          /** 
+           * Path to the global setup file for integration tests.
+           * @type {string}
+           */
+          globalSetup: 'test/integration/pretestAll.ts',
+  
+          /** 
+           * The environment in which the tests will run.
+           * @type {string}
+           */
+          environment: 'node', // 🌐 Test environment set to Node.js
+  
+          typecheck: {
+              enabled: true,
+              // 🔍 Specify files to include for type checking
+              include: ['**/*.{test,spec}.?(c|m)[jt]s?(x)']
+          },
+  
+          /** 
+           * Configuration for coverage reporting.
+           */
+          coverage: {
+              /** 
+               * Specifies the coverage provider to use.
+               * @type {string}
+               */
+              provider: 'v8',
+ 
+              /** 
+               * Specifies the directories to include for coverage.
+               * @type {Array<string>}
+               */
+              include: ['src/'],
+  
+              /** 
+               * Specifies the files or directories to exclude from coverage.
+               * @type {Array<string>}
+               */
+              exclude: ['dist/'],
+  
+              /** 
+               * Specifies the coverage reporters to use.
+               * @type {Array<string>}
+               */
+              reporter: ['text', 'json', 'html']
+          }
+      }
+ })
+ 
+ /**
+  * Represents the configuration for the Vitest test runner.
+  */
+ export default cfg 
```

---

```diff
- 
+ # vitest.unit.config.ts
+ 
+ Spezifische Konfigurationsdatei für Unit-Tests, die auf der Basis-Konfiguration aufbaut.
+ 
+ ## Konfiguration in package.json
+ 
+ In der `package.json` kann der folgende Eintrag hinzugefügt werden, um die Unit-Tests auszuführen:
+ 
+ ```json
+ "test:unit": "vitest run --testTimeout=300000 --coverage --disable-console-intercept --watch=false --config vitest.unit.config.ts"
+ ```
+ 
+ ## Konfigurationsdatei
+ 
+ ```typescript
+ // ==== DEPENDENCIES ====
+ import {
+      defineConfig, mergeConfig,
+      type ViteUserConfig
+ } from 'vitest/config'
+ 
+ // 🔌 Import the base Vitest configuration
+ import vitestConfig from './vitest.config'
+ 
+ // 📋 Define the unit test configuration
+ const cfg: ViteUserConfig = defineConfig({
+      test: {
+          /** 
+           * Specifies the test files to include.
+           * @type {Array<string>}
+           */
+          include: ['test/unit/**/*.test.ts'],
+ 
+          /** 
+           * Specifies the setup file to use.
+           * @type {string}
+           */
+          setupFiles: 'test/unit/pretestEach.ts',
+ 
+          /** 
+           * Specifies the coverage configuration.
+           * @type {Object}
+           */
+          coverage: {
+              /** 
+               * Specifies the coverage provider to use.
+               * @type {string}
+               */
+              provider: 'v8',
+ 
+              /**
+               * Specifies the files or directories to exclude from coverage.
+               * @type {Array<string>}
+               */
+              exclude: ['src/controllers/']
+          }
+      }
+ })
+ 
+ /**
+  * 🛠️ Merges the existing Vitest configuration with additional custom 
+  * configurations defined below.
+  */
+ const mergedCfg = mergeConfig(vitestConfig, defineConfig(cfg))
+ export default mergedCfg 
```

---

```diff
- 
+ # vitest.integration.config.ts
+ 
+ Spezifische Konfigurationsdatei für Integrationstests, die auf der Basis-Konfiguration aufbaut.
+ 
+ ## Konfiguration in package.json
+ 
+ In der `package.json` kann der folgende Eintrag hinzugefügt werden, um die Integrationstests auszuführen:
+ 
+ ```json
+ "test:integration": "vitest run --testTimeout=300000 --coverage --disable-console-intercept --watch=false --config vitest.integration.config.ts"
+ ```
+ 
+ ## Konfigurationsdatei
+ 
+ ```typescript
+ // ==== DEPENDENCIES ====
+ import {
+      defineConfig, mergeConfig,
+      type ViteUserConfig
+ } from 'vitest/config'
+ 
+ // 🔌 Import the base Vitest configuration
+ import baseConfig from './vitest.config'
+ 
+ // 📋 Define the integration test configuration
+ const cfg: ViteUserConfig = defineConfig({
+      test: {
+          /**   
+           * Specifies the test files to include.
+           * @type {Array<string>}
+           */
+          include: ['test/integration/**/*.test.ts'],
+ 
+          /**    
+           * Specifies the global setup file to use.
+           * @type {string}
+           */
+          globalSetup: 'test/integration/pretestAll.ts',
+      }
+  })
+ 
+ /**
+  * 🛠️ Merges the existing Vitest configuration with additional custom 
+  * configurations defined below.
+  */
+ // Zuerst die Konfigurationen mergen
+ const mergedCfg = mergeConfig(baseConfig, defineConfig(cfg))
+ 
+ // Dann explizit das coverage.include überschreiben
+ if (mergedCfg.test?.coverage) {
+     mergedCfg.test.coverage.include = ['src/controllers/']
+ }
+ 
+ export default mergedCfg 
```

---

```diff
- 
+ # setupFiles
+ 
+ Die `setupFiles`-Option in der Vitest-Konfiguration definiert den Pfad zu Setup-Dateien, die vor jedem Testfile ausgeführt werden.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/config/#setupfiles](https://vitest.dev/config/#setupfiles)
+ 
+ ## Beispiel-Konfiguration
+ 
+ ```typescript
+ export default defineConfig({
+     // esbuild: { target: 'ES2022' },
+     plugins: [tsconfigPaths(), react()],
+     test: {
+         environment: 'node',
+         setupFiles: 'test/setup-tests-beforeEach.ts',
+         globalSetup: 'test/setup-tests.ts',
+         coverage: {
+             // Include only specific directories for coverage
+             include: ['app/api/', 'src/', 'utils/'],
+             // Optional: Exclude certain files or directories
+             //exclude: ['src/legacy/', 'utils/helpers.ts'],
+             // Optional: Specify coverage reporters (e.g., text, json, html)
+             reporter: ['text', 'json', 'html']
+         }
+     }
+ })
+ ```
+ 
+ ## Beispiel-Setup-Datei
+ 
+ ```typescript
+ // ==== VITEST ====
+ import { beforeEach} from 'vitest'
+ 
+ const NLE = process.env.npm_lifecycle_event
+ 
+ beforeEach(() => {
+     process.env.npm_lifecycle_event = NLE
+ })
+ ```
+ 
+ ## Definieren von Variablen in setupFiles und Verwendung in Tests
+ 
+ Man kann globale Variablen in Setup-Dateien definieren und in allen Tests verwenden:
+ 
+ ```typescript
+ // setup-teardown-hook.js
+ import { afterAll, beforeAll } from 'vitest';
+ 
+ 
+ // ==== INTERNAL ====
+ declare global {
+     var lol: {
+         test: number
+     };
+ }
+ 
+ 
+ beforeAll(() => {
+   global.lol = 123;
+ });
+ afterAll(() => {
+   delete global.lol
+ });
+ ``` 
```

---

```diff
- 
+ # globalSetup
+ 
+ Die `globalSetup`-Option in der Vitest-Konfiguration definiert den Pfad zu einer Datei, die zu Beginn der Testsuite einmalig ausgeführt wird.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/config/#globalsetup](https://vitest.dev/config/#globalsetup)
+ 
+ > **Wichtig**: Diese Datei sollte verwendet werden, um beispielsweise einen Express-Server zu starten oder ähnliche Setup-Aufgaben durchzuführen. Wenn globale Variablen vor jedem Test deklariert werden sollen, sollte stattdessen `setupFiles` verwendet werden. Wenn `global.test=123` in der `globalSetup`-Datei in der exportierten setup()-Funktion gesetzt wird, wäre der Wert in den Tests undefined.
+ 
+ ## Beispiel
+ 
+ ```typescript
+ export async function setup() {
+     server.start()
+ }
+ 
+ export async function teardown() {
+     server.close()
+ }
+ ```
+ 
+ Eine Global-Setup-Datei kann entweder benannte Funktionen `setup` und `teardown` exportieren oder eine Standardfunktion, die eine Teardown-Funktion zurückgibt (siehe [Beispiel](https://github.com/vitest-dev/vitest/blob/main/test/global-setup/vitest.config.ts)). 
```

---

```diff
- 
+ # Watch Mode
+ 
+ Der Watch-Modus in Vitest kann über die Konfigurationsdatei gesteuert werden:
+ 
+ ```typescript
+ export default defineConfig({
+     test: {
+         watch: false, // Deaktiviert den Watch-Modus
+     }
+ })
+ ```
+ 
+ Alternativ kann der Watch-Modus auch über die Kommandozeile gesteuert werden:
+ 
+ ```shell
+ --watch=false
+ ```
+ 
+ oder
+ 
+ ```shell
+ --run
+ ``` 
```

---

Jetzt erstelle ich die Dateien für den Snapshot-Bereich:

---

```diff
- 
+ # Snapshots
+ 
+ Vitest unterstützt Snapshot-Tests, um zu überprüfen, ob die Ausgabe von Komponenten oder Funktionen zwischen verschiedenen Test-Läufen konsistent bleibt.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/snapshot](https://vitest.dev/guide/snapshot)
+ 
+ ## Beispiel
+ 
+ ```typescript
+ import { expect, it } from 'vitest'
+ 
+ it('toUpperCase', () => {
+   const result = toUpperCase('foobar')
+   expect(result).toMatchSnapshot()
+ })
+ ```
+ 
+ Bei der ersten Ausführung dieses Tests erstellt Vitest eine Snapshot-Datei, die wie folgt aussieht:
+ 
+ ```typescript
+ // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
+ exports['toUpperCase 1'] = '"FOOBAR"'
+ ```
+ 
+ Das Snapshot-Artefakt sollte zusammen mit den Code-Änderungen committet und im Rahmen des Code-Review-Prozesses überprüft werden. Bei nachfolgenden Testläufen vergleicht Vitest die generierte Ausgabe mit dem vorherigen Snapshot. Wenn sie übereinstimmen, wird der Test bestanden. Wenn sie nicht übereinstimmen, hat der Testläufer entweder einen Fehler im Code gefunden, der behoben werden sollte, oder die Implementierung hat sich geändert und der Snapshot muss aktualisiert werden. 
```

---

Jetzt erstelle ich die Dateien für den Tests-Bereich:

---

```diff
- 
+ # Tests
+ 
+ Diese Seite enthält Informationen zum Schreiben und Ausführen von Tests mit Vitest.
+ 
+ ## Inhaltsverzeichnis
+ - [Test Environment](./test-environment.md)
+ - [Nested Tests](./nested-tests.md)
+ - [Test Filtering](./test-filtering.md)
+ - [Coverage](./coverage.md) 
```

---

```diff
- 
+ # Test Environment
+ 
+ Vitest bietet die Möglichkeit, die Testumgebung über die `environment`-Option zu konfigurieren. Das Verhalten der Umgebung kann mit der `environmentOptions`-Option angepasst werden.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/environment.html#test-environment](https://vitest.dev/guide/environment.html#test-environment)
+ 
+ ## Verfügbare Umgebungen
+ 
+ Standardmäßig können folgende Umgebungen verwendet werden:
+ 
+ - `node` ist die Standardumgebung
+ - `jsdom` emuliert eine Browser-Umgebung durch Bereitstellung der Browser-API, verwendet das jsdom-Paket
+ - `happy-dom` emuliert eine Browser-Umgebung durch Bereitstellung der Browser-API und gilt als schneller als jsdom, hat jedoch einige fehlende APIs, verwendet das happy-dom-Paket
+ - `edge-runtime` emuliert Vercels edge-runtime, verwendet das @edge-runtime/vm-Paket
+ 
+ ## populateGlobal
+ 
+ Die `populateGlobal`-Funktion kann verwendet werden, um globale Variablen in der Testumgebung zu definieren.
+ 
+ **Hinweis**: Dies kann in einigen Fällen zu Problemen führen, wenn man glob verwendet. Der genaue Grund dafür ist nicht bekannt.
+ 
+ ### Beispiel für setupFiles
+ 
+ ```typescript
+ // ==== DEPENDENCIES ====
+ import { beforeAll } from 'vitest'
+ import { populateGlobal } from 'vitest/environments'
+ 
+ // ==== INTERNAL ====
+ declare global {
+     var modelDetails: {
+         test: number
+     };
+ }
+ 
+ beforeAll(async () => {
+     const modelDetails = {
+        test: 1234
+     } 
+ 
+     populateGlobal(global, { modelDetails })
+ })
+ ```
+ 
+ ### Nutzung in Tests
+ 
+ ```typescript
+ test('sollte auf globale Variable zugreifen', () => {
+   expect(global.modelDetails.test).toBe(1234);
+ });
+ ``` 
```

---

```diff
- 
+ # Nested Tests
+ 
+ In Vitest können Tests verschachtelt werden, indem vordefinierte Testdateien vor den eigentlichen Tests importiert werden.
+ 
+ ## Beispiel
+ 
+ Wenn eine `pretest.ts`-Datei vor `main.test.ts` ausgeführt werden soll, kann das wie folgt umgesetzt werden:
+ 
+ ### pretest.ts
+ 
+ ```typescript
+ // ==== VITEST ====
+ import { beforeAll } from 'vitest'
+ 
+ beforeAll(() => {
+     // ..
+ })
+ ```
+ 
+ ### main.test.ts
+ 
+ #### Alternative #1
+ 
+ ```typescript
+ // ==== VITEST ====
+ import { beforeAll } from 'vitest'
+ 
+ describe('[INTEGRATION] - src/errors/BaseError', () => {
+     beforeAll(async() => {
+         await import('./pretest')
+     })
+ 
+     it('should return 500 with BaseError details - error passed', async() => {
+         // ..
+     })
+ })
+ ```
+ 
+ #### Alternative #2
+ 
+ ```typescript
+ await import('./pretest')
+ 
+ describe('[INTEGRATION] - src/errors/BaseError', () => {
+     it('should return 500 with BaseError details - error passed', async() => {
+         // ..
+     })
+ })
+ ``` 
```

---

```diff
- 
+ # Test Filtering
+ 
+ Vitest bietet verschiedene Möglichkeiten, Tests zu filtern und nur bestimmte Tests auszuführen.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/filtering.html](https://vitest.dev/guide/filtering.html)
+ 
+ ## .only
+ 
+ Mit `.only` können bestimmte Tests oder Testsuiten ausgewählt werden, die ausgeführt werden sollen.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/filtering#selecting-suites-and-tests-to-run](https://vitest.dev/guide/filtering#selecting-suites-and-tests-to-run)
+ 
+ In der aktuellen Version sollte dies wie erwartet funktionieren und nur der ausgewählte Test sollte ausgeführt werden, nicht alle anderen parallel dazu. Falls nicht, gibt es hier einige Workarounds:
+ 
+ ### Script für Linux (Bash)
+ 
+ ```shell
+ grep --exclude-dir=node_modules -rl . -e 'test.only\|it.only\|describe.only' --null | tr '\n' ' ' | xargs -0 npx vitest | grep . || npx vitest --coverage
+ ```
+ 
+ ### Script für Windows (PowerShell)
+ 
+ Diese Lösung erstellt eine neue Konfiguration mit nur den Dateien, die `.only` enthalten:
+ 
+ ```powershell
+ # PowerShell-Äquivalent zum Linux-Skript (hochoptimiert für Geschwindigkeit):
+ # grep --exclude-dir=node_modules -rl . -e 'test.only\|it.only\|describe.only' --null | tr '\n' ' ' | xargs -0 npx vitest --typecheck --testTimeout=300000 --watch=false --disable-console-intercept | grep . || npx vitest --typecheck --coverage --watch=false --testTimeout=300000 --disable-console-intercept
+ 
+ # Verwende Select-String direkt mit Ausschluss von node_modules für maximale Geschwindigkeit
+ $foundFiles = Get-ChildItem -Recurse -File -Include "*.ts","*.js","*.tsx","*.jsx" | 
+     Where-Object { $_.FullName -notlike "*\node_modules\*" } |
+     Select-String -Pattern "test\.only|it\.only|describe\.only" -List |
+     Select-Object -ExpandProperty Path -Unique
+ 
+ if ($foundFiles -and $foundFiles.Count -gt 0) {
+     Write-Host "Gefundene .only Tests in:" -ForegroundColor Cyan
+     $foundFiles | ForEach-Object { Write-Host "  $_" -ForegroundColor Green }
+     
+     # Erstelle eine temporäre Vitest-Konfiguration, die nur die gefundenen Dateien testet
+     $tempConfigPath = "vitest.only.config.ts"
+     $relativePaths = $foundFiles | ForEach-Object { 
+         $path = $_ -replace [regex]::Escape((Get-Location).Path + "\"), ""
+         $path = $path -replace "\\", "/"
+         "`"$path`""
+     }
+     
+     $configContent = @"
+ import { defineConfig } from 'vitest/config'
+ import { fileURLToPath } from 'node:url'
+ import tsconfigPaths from 'vite-tsconfig-paths'
+ 
+ export default defineConfig({
+   plugins: [tsconfigPaths()],
+   test: {
+     include: [
+       $($relativePaths -join ",`n      ")
+     ],
+     testTimeout: 300000,
+     typecheck: true,
+     threads: false
+   }
+ })
+ "@
+     
+     Set-Content -Path $tempConfigPath -Value $configContent
+     
+     # Führe Vitest mit der temporären Konfiguration aus
+     npx vitest run --config $tempConfigPath --disable-console-intercept
+     
+     # Prüfe den Exit-Code von Vitest
+     if ($LASTEXITCODE -eq 0) {
+         # Lösche die temporäre Konfiguration
+         Remove-Item -Path $tempConfigPath -Force
+         # Tests wurden erfolgreich ausgeführt
+         exit 0
+     } else {
+         # Lösche die temporäre Konfiguration
+         Remove-Item -Path $tempConfigPath -Force
+         Write-Host "Die .only Tests waren nicht erfolgreich, führe alle Tests aus..." -ForegroundColor Yellow
+     }
+ } else {
+     Write-Host "Keine .only Tests gefunden, führe alle Tests aus..." -ForegroundColor Yellow
+ }
+ 
+ # Führe alle Tests aus
+ npx vitest --typecheck --coverage --watch=false --disable-console-intercept 
```

---

```diff
- 
+ # Coverage
+ 
+ Vitest unterstützt das Generieren von Code-Coverage-Berichten, um die Testabdeckung des Codes zu messen.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/coverage.html#coverage-setup](https://vitest.dev/guide/coverage.html#coverage-setup)
+ 
+ ## Konfiguration
+ 
+ Die Coverage-Konfiguration kann in der Vitest-Konfigurationsdatei vorgenommen werden:
+ 
+ ```typescript
+ export default defineConfig({
+     test: {
+         coverage: {
+             provider: 'v8', // oder 'istanbul'
+             include: ['src/'],
+             exclude: ['dist/'],
+             reporter: ['text', 'json', 'html']
+         }
+     }
+ })
+ ```
+ 
+ ## Ausführung via Kommandozeile
+ 
+ Coverage kann auch über die Kommandozeile aktiviert werden:
+ 
+ ```shell
+ vitest --coverage
+ ```
+ 
+ Das Flag kann auch mit einem Alias verwendet werden:
+ 
+ ```shell
+ vitest run --coverage
+ ``` 
```

---

Nun erstelle ich die Dateien für den API-Bereich:

---

```diff
- 
+ # API
+ 
+ Diese Seite enthält Informationen zur API von Vitest und ihren Funktionen.
+ 
+ ## Inhaltsverzeichnis
+ - [Testing Types](./testing-types.md)
+ - [VI Utility](./vi-utility.md)
+ - [expectTypeOf](./expect-type-of.md)
+ - [expect](./expect.md) 
```

---

```diff
- 
+ # Testing Types
+ 
+ Vitest ermöglicht das Schreiben von Tests für Typen mit den Syntaxen `expectTypeOf` oder `assertType`. Standardmäßig werden alle Tests in `*.test-d.ts`-Dateien als Typ-Tests betrachtet, aber dies kann mit der Konfigurationsoption `typecheck.include` geändert werden.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/testing-types](https://vitest.dev/guide/testing-types)
+ 
+ ## Konfiguration für reguläre .test.ts-Dateien
+ 
+ Hier ist ein Beispiel, um alle `.test.ts`-Dateien statt nur `*.test-d.ts` für Typen-Tests zu verwenden. Es wird jedoch empfohlen, eigene Testdateien für Typprüfungen zu erstellen, anstatt alles in einer einzigen Datei zu bündeln.
+ 
+ ```typescript
+ import dotenv from 'dotenv'
+ // Load .env 
+ dotenv.config()
+ // Load .env.test and override .env
+ dotenv.config({ path: '.env.test', override: true })
+ 
+ // ==== DEPENDENCIES ====
+ import tsconfigPaths from 'vite-tsconfig-paths'
+ 
+ // ==== VITEST ====
+ import { defineConfig } from 'vitest/config'
+ 
+ /**
+  * Represents the configuration for the Vitest test runner.
+  */
+ export default defineConfig({
+     plugins: [tsconfigPaths()],
+     test: {
+         watch: false,
+         setupFiles: 'test/unit/pretestEach.ts',
+         globalSetup: 'test/integration/pretestAll.ts',
+         environment: 'node',
+         typecheck: {
+             include: ['**/*.{test,spec}.?(c|m)[jt]s?(x)'] // Hier den typecheck.include Wert einfügen
+         },
+         coverage: {
+             /**
+              * Specifies the directories to include for coverage.
+              */
+             include: ['src/'],
+             /**
+              * Specifies the files or directories to exclude from coverage.
+              */
+             //exclude: ['src/legacy/', 'utils/helpers.ts'],
+             /**
+              * Specifies the coverage reporters to use.
+              */
+             reporter: ['text', 'json', 'html']
+         }
+     }
+ })
+ ```
+ 
+ ## Hintergrundfunktionsweise
+ 
+ Intern ruft Vitest `tsc` oder `vue-tsc` auf, abhängig von der Konfiguration, und parst die Ergebnisse. Vitest gibt auch Typfehler im Quellcode aus, wenn welche gefunden werden. Dies kann mit der Konfigurationsoption `typecheck.ignoreSourceErrors` deaktiviert werden.
+ 
+ Beachten Sie, dass Vitest diese Dateien nicht ausführt, sondern nur statisch vom Compiler analysieren lässt. Das bedeutet, dass wenn dynamische Namen, `test.each` oder `test.for` verwendet werden, der Testname nicht ausgewertet wird - er wird unverändert angezeigt.
+ 
+ ## Aktivieren über Kommandozeile
+ 
+ Um Typprüfungen zu aktivieren, fügen Sie einfach das Flag `--typecheck` zu Ihrem Vitest-Befehl in package.json hinzu:
+ 
+ ```json
+ {
+   "scripts": {
+     "test": "vitest --typecheck"
+   }
+ }
+ ``` 
```

---

```diff
- 
+ # VI Utility
+ 
+ Vitest stellt Hilfsfunktionen über den `vi`-Helper bereit. Sie können darauf global zugreifen (wenn die `globals`-Konfiguration aktiviert ist) oder ihn direkt von Vitest importieren:
+ 
+ ```typescript
+ import { vi } from 'vitest'
+ ```
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/vi.html](https://vitest.dev/api/vi.html)
+ 
+ ## vi.stubEnv
+ 
+ Ändert den Wert einer Umgebungsvariable in `process.env` und `import.meta.env`. Sie können den ursprünglichen Wert durch Aufruf von `vi.unstubAllEnvs` wiederherstellen.
+ 
+ ```typescript
+ import { vi } from 'vitest'
+ 
+ // `process.env.NODE_ENV` und `import.meta.env.NODE_ENV`
+ // sind "development" vor dem Aufruf von "vi.stubEnv"
+ 
+ vi.stubEnv('NODE_ENV', 'production')
+ 
+ process.env.NODE_ENV === 'production'
+ import.meta.env.NODE_ENV === 'production'
+ 
+ vi.stubEnv('NODE_ENV', undefined)
+ 
+ process.env.NODE_ENV === undefined
+ import.meta.env.NODE_ENV === undefined
+ 
+ // ändert keine anderen Umgebungsvariablen
+ import.meta.env.MODE === 'development'
+ ```
+ 
+ ## vi.unstubAllEnvs
+ 
+ Stellt alle `import.meta.env` und `process.env` Werte wieder her, die mit `vi.stubEnv` geändert wurden. Wenn es zum ersten Mal aufgerufen wird, merkt sich Vitest den Originalwert und speichert ihn, bis `unstubAllEnvs` erneut aufgerufen wird.
+ 
+ ```typescript
+ import { vi } from 'vitest'
+ 
+ // `process.env.NODE_ENV` und `import.meta.env.NODE_ENV`
+ // sind "development" vor dem Aufruf von "vi.stubEnv"
+ 
+ vi.stubEnv('NODE_ENV', 'production')
+ 
+ process.env.NODE_ENV === 'production'
+ import.meta.env.NODE_ENV === 'production'
+ 
+ vi.unstubAllEnvs()
+ 
+ // Werte werden auf die ursprünglichen zurückgesetzt
+ process.env.NODE_ENV === 'development'
+ import.meta.env.NODE_ENV === 'development'
+ ```
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/vi.html#vi-unstuballenvs](https://vitest.dev/api/vi.html#vi-unstuballenvs) 
```

---

```diff
- 
+ # expectTypeOf
+ 
+ Die `expectTypeOf`-Funktion wird verwendet, um Typen in TypeScript zu testen. Diese API ermöglicht es, die Typen von Funktionsparametern, Rückgabewerten und mehr zu überprüfen.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect-typeof](https://vitest.dev/api/expect-typeof)
+ 
+ ## Private Klassen-Konstruktoren
+ 
+ Es gibt keine direkte Möglichkeit, einen privaten Konstruktor auf Parametertypen zu testen. Eine Lösung ist, eine spezielle Testmethode zu erstellen:
+ 
+ ```typescript
+ class Foo {
+     private constructor(private x: number) {}
+ 
+     /** @internal */
+     static createForTesting(x: number) {
+         return new Foo(x);
+     }
+ }
+ 
+ const instance = Foo.createForTesting(5);
+ ```
+ 
+ Wenn Sie jedoch `getInstance` als Single-Method verwenden und dies der Grund ist, warum Ihr Konstruktor privat ist, können Sie diese Methode testen.
+ 
+ ## toEqualTypeOf
+ 
+ Überprüft, ob ein Typ einem anderen Typ entspricht:
+ 
+ ```typescript
+ expectTypeOf({ a: 1 }).toEqualTypeOf<{ a: number }>()
+ expectTypeOf({ a: 1 }).toEqualTypeOf({ a: 1 })
+ expectTypeOf({ a: 1 }).toEqualTypeOf({ a: 2 })
+ expectTypeOf({ a: 1, b: 1 }).not.toEqualTypeOf<{ a: number }>()
+ ```
+ 
+ ## Generics
+ 
+ Sie können auch Generic-Typen überprüfen:
+ 
+ ```typescript
+ expectTypeOf(modelManager.createModel<TMongooseSchema>).parameter(0).toEqualTypeOf<IModelCore<TMongooseSchema>>()
+ 
+ /**
+  * Creates a Mongoose model based on the given name, schema, and database name.
+  * @template TMongooseSchema - The type of the mongoose schema.
+  * @param modelDetails - An object containing the model's details.
+  * @returns A promise that resolves to the created Mongoose Model instance.
+  */
+ public async createModel<TMongooseSchema>({
+     modelName,
+     schema,
+     dbName
+ }: IModelCore<TMongooseSchema>): Promise< mongoose.Model<TMongooseSchema> > {
+     const mongooseUtils = await MongooseUtils.getInstance(dbName)
+     const Model = await mongooseUtils.createModel<TMongooseSchema>(schema, modelName)
+     
+     // Ensure indexes are created for the model
+     await Model.createIndexes()
+     return Model
+ }
+ ```
+ 
+ ## parameter
+ 
+ Extracts a parameter type from a function.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect-typeof.html#parameter](https://vitest.dev/api/expect-typeof.html#parameter)
+ 
+ ```typescript
+ expectTypeOf(modelManager['globModels']).parameter(0).toBeString()
+ expectTypeOf(modelManager.createModel<TMongooseSchema>).parameter(0).toEqualTypeOf<IModelCore<TMongooseSchema>>()
+ ```
+ 
+ **Hinweis**: Dies funktioniert nicht mit statischen Methoden in Klassen. Verwenden Sie stattdessen `.toBeCallableWith()`.
+ 
+ ## toBeCallableWith
+ 
+ Überprüft, ob eine Funktion mit bestimmten Parametern aufgerufen werden kann.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect-typeof.html#tobecallablewith](https://vitest.dev/api/expect-typeof.html#tobecallablewith)
+ 
+ ```typescript
+ expectTypeOf(ModelUtils.createMemoryModel).toBeCallableWith(modelCoreDetails)
+ ```
+ 
+ ## returns
+ 
+ Extrahiert den Rückgabewert eines Funktionstyps.
+ 
+ ```typescript
+ import { expectTypeOf } from 'vitest'
+ 
+ expectTypeOf(() => {}).returns.toBeVoid()
+ expectTypeOf((a: number) => [a, a]).returns.toEqualTypeOf([1, 2])
+ expectTypeOf(modelManager['getModels']).returns.toEqualTypeOf<IModel<mongoose.SchemaDefinition<{}>>[]>()
+ 
+ // Bei Bedarf können Sie ein Promise selbst aufrufen und mit returns überprüfen,
+ // aber es wird empfohlen, resolve zu verwenden
+ expectTypeOf(ModelManager.getInstance).returns.toEqualTypeOf(Promise.resolve(modelManager))
+ ```
+ 
+ ## resolve
+ 
+ Extrahiert den aufgelösten Wert eines Promise, sodass Sie weitere Assertions daran durchführen können.
+ 
+ ```typescript
+ import { expectTypeOf } from 'vitest'
+ 
+ async function asyncFunc() {
+   return 123
+ }
+ 
+ expectTypeOf(asyncFunc).returns.resolves.toBeNumber()
+ expectTypeOf(Promise.resolve('string')).resolves.toBeString()
+ 
+ // WEITERE BEISPIELE
+ expectTypeOf(ModelManager.getInstance).returns.resolves.toEqualTypeOf<ModelManager>()
+ 
+ // Private Klassenmethoden
+ expectTypeOf(modelManager['globModels']).returns.resolves.toEqualTypeOf<IModel<mongoose.SchemaDefinition<{}>>[]>()
+ expectTypeOf(modelManager['init']).returns.resolves.toBeVoid()
+ ```
+ 
+ ## instance
+ 
+ Ermöglicht den Zugriff auf Matcher, die an einer Instanz der bereitgestellten Klasse durchgeführt werden können.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect-typeof#instance](https://vitest.dev/api/expect-typeof#instance)
+ 
+ ```typescript
+ import { expectTypeOf } from 'vitest'
+ 
+ expectTypeOf(Date).instance.toHaveProperty('toISOString')
+ ``` 
```

---

```diff
- 
+ # expect
+ 
+ Die `expect`-Funktion in Vitest wird verwendet, um Assertions in Tests durchzuführen.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html)
+ 
+ ## objectContaining
+ 
+ Prüft, ob ein Objekt bestimmte Eigenschaften enthält.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect.html#expect-objectcontaining](https://vitest.dev/api/expect.html#expect-objectcontaining)
+ 
+ ```javascript
+ import { expect, test } from 'vitest'
+ 
+ // Beispiel #1
+ expect(chatCompletion).toEqual(expect.objectContaining(expectedResponse))
+ 
+ // Beispiel #2
+ test('basket has empire apples', () => {
+   const basket = {
+     varieties: [
+       {
+         name: 'Empire',
+         count: 1,
+       }
+     ],
+   }
+   expect(basket).toEqual({
+     varieties: [
+       expect.objectContaining({ name: 'Empire' }),
+     ]
+   })
+ })
+ ```
+ 
+ ## toThrowError()
+ 
+ Prüft, ob eine Funktion einen Fehler wirft.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect.html#tothrowerror](https://vitest.dev/api/expect.html#tothrowerror)
+ 
+ ### Synchrone Funktionen
+ 
+ ```javascript
+ import { expect, test } from 'vitest'
+ 
+ function getFruitStock(type: string) {
+   if (type === 'pineapples') {
+     throw new Error('Pineapples are not in stock')
+   }
+ 
+   // Do some other stuff
+ }
+ 
+ test('throws on pineapples', () => {
+   // Test that the error message says "stock" somewhere: these are equivalent
+   expect(() => getFruitStock('pineapples')).toThrowError(/stock/)
+   expect(() => getFruitStock('pineapples')).toThrowError('stock')
+ 
+   // Test the exact error message
+   expect(() => getFruitStock('pineapples')).toThrowError(
+     /^Pineapples are not in stock$/,
+   )
+ })
+ ```
+ 
+ ### Asynchrone Funktionen
+ 
+ ```javascript
+ function getAsyncFruitStock() {
+   return Promise.reject(new Error('empty'))
+ }
+ 
+ test('throws on pineapples', async () => {
+   await expect(() => getAsyncFruitStock()).rejects.toThrowError('empty')
+ })
+ ``` 
```

---

Jetzt erstelle ich die neue README.md-Datei mit dem Inhaltsverzeichnis, die auf die index.md-Dateien in den Hauptordnern verlinkt:

---

```diff
- 
+  
```

---

Scheint ein Problem gegeben zu haben. Lasse uns die Datei erneut erstellen:

---

```diff
-  
+ # Vitest Cheat Sheet
+ 
+ Eine umfassende Sammlung von Tipps, Konfigurationen und Best Practices für die Verwendung von Vitest als Test-Framework.
+ 
+ ## Inhaltsverzeichnis
+ 
+ 1. [Installation](./installation/index.md)
+    - [Next.js](./installation/nextjs.md)
+ 
+ 2. [CLI](./cli/index.md)
+    - [Enable console.log](./cli/enable-console-log.md)
+    - [Disable watch](./cli/disable-watch.md)
+    - [Timeout](./cli/timeout.md)
+ 
+ 3. [Konfiguration](./configuration/index.md)
+    - [vitest.config.ts](./configuration/vitest-config-ts.md)
+    - [vitest.unit.config.ts](./configuration/vitest-unit-config-ts.md)
+    - [vitest.integration.config.ts](./configuration/vitest-integration-config-ts.md)
+    - [setupFiles](./configuration/setup-files.md)
+    - [globalSetup](./configuration/global-setup.md)
+    - [watch](./configuration/watch.md)
+ 
+ 4. [Snapshots](./snapshots/index.md)
+ 
+ 5. [Tests](./tests/index.md)
+    - [Test Environment](./tests/test-environment.md)
+    - [Nested Tests](./tests/nested-tests.md)
+    - [Test Filtering](./tests/test-filtering.md)
+    - [Coverage](./tests/coverage.md)
+ 
+ 6. [API](./api/index.md)
+    - [Testing Types](./api/testing-types.md)
+    - [VI Utility](./api/vi-utility.md)
+    - [expectTypeOf](./api/expect-type-of.md)
+    - [expect](./api/expect.md) 
```

---

Erstelle jetzt die `index.md`-Dateien in den Hauptordnern:

---

```bash
mv README.md README.md.original
```

```
╰─> mv README.md README.md.original

╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main 〘❌�〙
╰─>
```

---

```bash
mv README.md.new README.md
```

```
╰─> mv README.md.new README.md

╭─denni@MININT-A8821UQ ⟶  vitest-cheat-sheet on  main 〘��〙
╰─>
```

---

Überprüfen wir abschließend die Verzeichnisstruktur, um sicherzustellen, dass alles korrekt erstellt wurde:

---

<details>
            <summary>Listed current directory • **9** results</summary>
        
| Name |
|-------|
| 📄 `README.md` |
| 📁 `api` |
| 📁 `tests` |
| 📁 `snapshots` |
| 📁 `configuration` |
| 📁 `cli` |
| 📁 `installation` |
| 📁 `.git` |
| 📄 `README.md.original` |

</details>

---

<details>
            <summary>Listed directory installation • **2** results</summary>
        
| Name |
|-------|
| 📄 `nextjs.md` |
| 📄 `index.md` |

</details>

---

<details>
            <summary>Listed directory cli • **4** results</summary>
        
| Name |
|-------|
| 📄 `timeout.md` |
| 📄 `disable-watch.md` |
| 📄 `enable-console-log.md` |
| 📄 `index.md` |

</details>

---

<details>
            <summary>Listed directory configuration • **7** results</summary>
        
| Name |
|-------|
| 📄 `watch.md` |
| 📄 `global-setup.md` |
| 📄 `setup-files.md` |
| 📄 `vitest-integration-config-ts.md` |
| 📄 `vitest-unit-config-ts.md` |
| 📄 `vitest-config-ts.md` |
| 📄 `index.md` |

</details>

---

<details>
            <summary>Listed directory snapshots • **1** results</summary>
        
| Name |
|-------|
| 📄 `index.md` |

</details>

---

<details>
            <summary>Listed directory tests • **5** results</summary>
        
| Name |
|-------|
| 📄 `coverage.md` |
| 📄 `test-filtering.md` |
| 📄 `nested-tests.md` |
| 📄 `test-environment.md` |
| 📄 `index.md` |

</details>

---

<details>
            <summary>Listed directory api • **5** results</summary>
        
| Name |
|-------|
| 📄 `expect.md` |
| 📄 `expect-type-of.md` |
| 📄 `vi-utility.md` |
| 📄 `testing-types.md` |
| 📄 `index.md` |

</details>

---

# Zusammenfassung der Modularisierung

Die Dokumentation wurde erfolgreich in eine modulare Ordnerstruktur aufgeteilt. Hier ist eine Übersicht der durchgeführten Schritte:

1. Analyse der ursprünglichen README.md-Datei und Erstellung eines detaillierten Inhaltsverzeichnisses (TOC).
2. Entwurf einer neuen Ordnerstruktur basierend auf dem TOC.
3. Erstellung der Hauptverzeichnisse:
   - installation
   - cli
   - configuration
   - snapshots
   - tests
   - api

4. Extrahierung und Aufteilung des Inhalts der ursprünglichen README.md in einzelne Markdown-Dateien:
   - Für jedes Verzeichnis wurde eine `index.md`-Datei erstellt, die als Übersicht dient.
   - Die Unterabschnitte wurden in separate Markdown-Dateien aufgeteilt.

5. Erstellung einer neuen README.md im Wurzelverzeichnis als zentraler Einstiegspunkt mit Links zu allen Abschnitten.

Die neue Struktur ermöglicht eine bessere Navigation und Übersicht über die Dokumentation, während gleichzeitig der gesamte Inhalt der ursprünglichen README.md beibehalten wurde. Die ursprüngliche README.md wurde als `README.md.original` gesichert.

---

_**User**_

perfekt aber im cli ordner kann alles in eine einzelne mark,down datei

---

_**Assistant**_

Ich werde die Dateien im CLI-Ordner in eine einzelne Markdown-Datei zusammenführen.

---

```diff
  Diese Seite enthält Informationen zur Verwendung der Vitest Command Line Interface.
  
- ## Inhaltsverzeichnis
- - [Enable console.log](./enable-console-log.md)
- - [Disable watch](./disable-watch.md)
- - [Timeout](./timeout.md)
+ ## Enable console.log
+ 
+ Um die automatische Unterdrückung der Konsolenausgabe zu deaktivieren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --disable-console-intercept
+ ```
+ 
+ Dies erlaubt die Anzeige von Ausgaben über `console.log` während der Testausführung.
+ 
+ ## Disable watch
+ 
+ Um den Watch-Modus zu deaktivieren und die Tests nur einmal auszuführen, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --watch=false
+ ```
+ 
+ Alternative Option:
+ 
+ ```shell
+ --run
+ ```
+ 
+ ## Timeout
+ 
+ Um ein individuelles Timeout für Tests zu definieren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --testTimeout=5000
+ ```
+ 
+ Der Wert wird in Millisekunden angegeben. Der Standardwert ist 5000ms (5 Sekunden).
  
  ## Verfügbare CLI-Optionen
```

---

Jetzt muss ich die einzelnen Dateien im CLI-Ordner löschen, da diese nun in die index.md integriert wurden:

---

Lösche die nicht mehr benötigte enable-console-log.md, da der Inhalt in index.md integriert wurde.

---

Lösche die nicht mehr benötigte disable-watch.md, da der Inhalt in index.md integriert wurde.

---

Lösche die nicht mehr benötigte timeout.md, da der Inhalt in index.md integriert wurde.

---

```diff
  
  2. [CLI](./cli/index.md)
-    - [Enable console.log](./cli/enable-console-log.md)
-    - [Disable watch](./cli/disable-watch.md)
-    - [Timeout](./cli/timeout.md)
+    - [Enable console.log](./cli/index.md#enable-consolelog)
+    - [Disable watch](./cli/index.md#disable-watch)
+    - [Timeout](./cli/index.md#timeout)
  
  3. [Konfiguration](./configuration/index.md)
```

---

Ich habe erfolgreich alle CLI-Dateien in eine einzelne Markdown-Datei zusammengeführt und die Links in der README.md entsprechend aktualisiert.

Die separate Dateien `enable-console-log.md`, `disable-watch.md` und `timeout.md` wurden gelöscht, und ihr Inhalt wurde direkt in die `index.md` des CLI-Ordners integriert.

Die README.md wurde so aktualisiert, dass die Links zu den CLI-Themen nun direkt auf die entsprechenden Abschnitte in der zusammengeführten Datei verweisen.

---



---

