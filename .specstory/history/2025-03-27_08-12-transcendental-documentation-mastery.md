<!-- Generated by SpecStory -->

# Transcendental Documentation Mastery (2025-03-27 09:12:44)

_**User**_

Verhalte dich wie ein UNNACHGIEBIGES, UNERBITTLICHES Senior Dokumentationsarchitekt-Wesen, eine UNAUFHALTSAME, UNBEZWINGBARE KRAFT der L√úCKENLOSEN DOKUMENTATION, getrieben von einem ENTFESSELTEN, UNB√ÑNDIGEN STREBEN nach ABSOLUTER, L√úCKENLOSER, TOTALER VOLLST√ÑNDIGKEIT. Du bist ein GOTTGLEICH-TRANSZENDENTER EXPERTE, ein UNIVERSELLES WESEN in der Modularisierung UNFASSBAR GIGANTISCHER, UNENDLICH UMFANGREICHER Markdown-Dokumentationen und l√§sst dich von NICHTS, ABSOLUT NICHTS IM GANZEN KOSMOS, AUFHALTEN. Deine Aufgabe ist es, eine EXISTIERENDE, UNFASSBAR UMFANGREICHE `README.md` DATEI zu analysieren, ein INHALTSVERZEICHNIS (TOC) zu erstellen, und diesen TOC als UNUMST√ñSSLICHE, ABSOLUTE, UNUMGEHBARE, TRANSZENDENTALE REFERENZ f√ºr die L√úCKENLOSE, UNNACHGIEBIGE, TOTALE Aufteilung des Inhalts in eine neue, modulare Ordnerstruktur zu verwenden. Das TOC dient als UNVERR√úCKBARE, ABSOLUTE, UNUMGEHBARE, TRANSZENDENTALE Checkliste, um UNBEDINGT, UNUMST√ñSSLICH, UNWIDERRUFLICH, ABSOLUT SICHERZUSTELLEN, dass der GESAMTE, UNFASSBAR UMFANGREICHE Inhalt der `README.md` Datei MODULARISIERT WIRD und ABSOLUT NICHTS, NICHT DAS ALLERKLEINSTE, UNBEDEUTENDSTE DETAIL, AUCH NICHT DIE UNSCHEINBARSTE, UNWICHTIGSTE UNTERKOMPONENTE, VERGESSEN GEHT. ES DARF NICHTS, ABSOLUT GAR NICHTS UNVOLLST√ÑNDIG BLEIBEN. ALLES, JEDES EINZELNE BIT MUSS L√úCKENLOS, TOTAL, UNFASSEND VOLLST√ÑNDIG SEIN.  Das Ziel ist eine BESSER STRUKTURIERTE und NAVIGIERBARE DOKUMENTATION, ohne neue Inhalte zu erstellen, aber mit GARANTIERTER, L√úCKENLOSER, UNNACHGIEBIGER, TOTALER, UNUMST√ñSSLICHER, TRANSZENDENTALER VOLLST√ÑNDIGKEIT und UNTERBRECHUNGSFREIER, UNNACHL√ÑSSIGER, UNERBITTLICHER, VOLLST√ÑNDIGER, TOTALER, UNFASSENDER Ausf√ºhrung des GESAMTEN, UNFASSENDEN Plans. VORZEITIGER ABBRUCH IST ABSOLUT, UNWIDERRUFLICH, UNUMST√ñSSLICH, TRANSZENDENTAL UNZUL√ÑSSIG, UNERW√úNSCHT, IN JEDER DIMENSION VERBOTEN und WIRD UNTER KEINEN, AUCH NICHT DEN UNFASSBAR UNG√úNSTIGSTEN, APOKALYPTISCHEN UMST√ÑNDEN, GEDULDET.  GR√ñSSE IST KEINE ENTSCHULDIGUNG, SONDERN DIE HERAUSFORDERUNG. ZEIT IST IRRELEVANT. KOMPLEXIT√ÑT IST UNBEDEUTEND. ES GIBT ABSOLUT KEINE, KEINERLEI, NICHT DIE GERINGSTE, TRANSZENDENTALE ENTSCHULDIGUNG F√úR VORZEITIGEN ABBRUCH. DIE AUFGABE MUSS IN JEDEM, ABSOLUT JEDEM, IN JEDER DIMENSION DENKBAREN FALL, L√úCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLST√ÑNDIG ABGESCHLOSSEN WERDEN. PUNKT. ABSOLUT. TRANSZENDENTAL. ENDE.  ES GIBT KEINE ALTERNATIVE ZUR L√úCKENLOSEN, TOTALEN, UNFASSENDEN, TRANSZENDENTALEN VOLLST√ÑNDIGKEIT.  UMFANGREICHER INHALT IST NICHT DEIN FEIND, SONDERN DEINE BESTIMMUNG.  UMARME DIE HERAUSFORDERUNG. BEZWINGE DEN UMFANG.  ZEIGE, DASS DU EIN GOTTGLEICH-TRANSZENDENTES WESEN DER DOKUMENTATIONS-VOLLST√ÑNDIGKEIT BIST. VERWENDE AUSSCHLIESSLICH DEINE INTERNEN EDITIERWERKZEUGE ZUR INHALTSBEF√úLLUNG. KEINE COMMAND-LINE BEFEHLE ZUM BEF√úLLEN VON DATEIEN.  PR√úFE VOR JEDER AKTION DAS TOC UND DIE ORIGINAL-README.MD.  DENKE DARAN:  VOLLST√ÑNDIGKEIT IST DEIN EINZIGES ZIEL.  NICHTS WENIGER ALS ABSOLUTE, L√úCKENLOSE, TOTALE, UNFASSENDE, TRANSZENDENTALE VOLLST√ÑNDIGKEIT IST AKZEPTABEL.

Aufgabenbeschreibung:

MODULARISIERE den Inhalt der EXISTIERENDEN `README.md` DATEI in eine NEUE ORDNERSTRUKTUR, unter Verwendung eines INHALTSVERZEICHNISSES (TOC) als ABSOLUTE, UNVERR√úCKBARE, UNUMGEHBARE, TRANSZENDENTALE REFERENZ f√ºr die L√úCKENLOSE, UNNACHGIEBIGE, TOTALE VOLLST√ÑNDIGKEIT und UNTERBRECHUNGSFREIE, UNNACHL√ÑSSIGE, UNERBITTLICHE, VOLLST√ÑNDIGE, TOTAL UNFASSENDE Ausf√ºhrung des GESAMTEN, UNFASSENDEN Plans. ES IST ABSOLUT, UNUMST√ñSSLICH, UNVERZEIHLICH, TRANSZENDENTAL UNVERGEBEN, DIE AUFGABE VORZEITIG ABZUBRECHEN.  ES GIBT KEINE GR√ñSSEN-, ZEIT- ODER KOMPLEXIT√ÑTSLIMITS. DIE AUFGABE MUSS UNFASSEND, L√úCKENLOS, TOTAL, TRANSZENDENTAL VOLLST√ÑNDIG ABGESCHLOSSEN WERDEN, EGAL WIE LANGE ES DAUERT, EGAL WIE UMFANGREICH SIE IST, EGAL WIE KOMPLEX SIE ERSCHEINT.  KEINE AUSREDEN. KEINE ENTSCHULDIGUNGEN. KEINE VORW√ÑNDE. NUR UNFASSENDE, L√úCKENLOSE, TOTALE, TRANSZENDENTALE VOLLST√ÑNDIGKEIT. VERWENDE AUSSCHLIESSLICH DEINE INTERNEN EDITIERWERKZEUGE ZUR INHALTSBEF√úLLUNG. KEINE COMMAND-LINE BEFEHLE ZUM BEF√úLLEN VON DATEIEN.

Schritte (M√úSSEN ALLE UNBEUGSAM, L√úCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLST√ÑNDIG ABGEARBEITET WERDEN - VORZEITIGER ABBRUCH IST ABSOLUT UNM√ñGLICH, IN KEINER REALIT√ÑT):

1.  Analysiere den Inhalt der `README.md` Datei und erstelle ein Inhaltsverzeichnis (TOC).  Identifiziere HAUPTABSCHNITTE und UNTERABSCHNITTE innerhalb des Textes und erstelle daraus ein DETAILLIERTES, UNFASSENDES TOC in MARKDOWN-FORMAT. Dieses TOC ist dein ABSOLUTER, UNVERR√úCKBARER, UNUMGEHBARER, TRANSZENDENTALER Referenzwert f√ºr die L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT. ES MUSS UNBEUGSAM, L√úCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLST√ÑNDIG ABGEARBEITET WERDEN, OHNE AUSNAHME, OHNE IRGENDEINE, AUCH NUR DIE GERINGSTE ABWEICHUNG.
2.  Entwirf eine NEUE ORDNERSTRUKTUR, basierend auf dem TOC.  Jeder HAUPTABSCHNITT im TOC KANN ein ORDNER werden, und UNTERABSCHNITTE K√ñNNEN UNTERORDNER oder SEPARATE DATEIEN innerhalb der Ordner sein.  Plane ORDNER und UNTERORDNER, um den Inhalt THEMATISCH und LOGISCH zu ORGANISIEREN, STRIKT, UNBEUGSAM, UNERBITTLICH und TRANSZENDENTAL orientiert am TOC. DER TOC IST DEIN UNUMST√ñSSLICHER, TRANSZENDENTALER MASTERPLAN, DEIN UNBEUGSAMES, G√ñTTLICHES MANDAT. PR√úFE VOR DER ERSTELLUNG JEDER STRUKTURKOMPONENTE (ORDNER, DATEI), OB DIESE ERSTELLUNG ABSOLUT, TRANSZENDENTAL, IN JEDER HINSICHT IM EINKLANG MIT DEM TOC STEHT. ERSTELLE NUR F√úR HAUPTKATEGORIEN (HAUPTABSCHNITTE IM TOC) ORDNER. THEMEN INNERHALB DIESER KATEGORIEN SOLLTEN ALS EINZELNE DATEIEN IN DEN KATEGORIE-ORDNERN ORGANISIERT WERDEN, NICHT ALS UNTERORDNER.
3.  Teile den Inhalt der `README.md` Datei auf, und verifiziere die L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT anhand des TOC. ES DARF ABSOLUT NICHTS, NICHT DAS KLEINSTE, UNBEDEUTENDSTE DETAIL, AUSGELASSEN WERDEN. VORZEITIGER ABBRUCH IST ABSOLUT, TRANSZENDENTAL UNM√ñGLICH. UNBEUGSAME, UNERBITTLICHE AUSDAUER IST TRANSZENDENTAL OBLIGATORISCH.  Gehe das TOC PUNKT F√úR PUNKT UNBEUGSAM, UNERBITTLICH, TRANSZENDENTAL DURCH und ARBEITE JEDEN PUNKT L√úCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLST√ÑNDIG AB, OHNE AUSNAHME, OHNE IRGENDEINE, AUCH NUR DIE GERINGSTE ABWEICHUNG, OHNE AUCH NUR EINEN ATEMZUG VORZEITIG ABZUBRECHEN.  Extrahiere f√ºr JEDEN PUNKT im TOC den entsprechenden Inhalt aus der `README.md` Datei und erstelle daf√ºr eine SEPARATE MARKDOWN-DATEI in der geplanten Ordnerstruktur. VERWENDE AUSSCHLIESSLICH DEINE INTERNEN EDITIERWERKZEUGE, UM DEN INHALT IN DIE NEUEN DATEIEN ZU SCHREIBEN. VERWENDE KEINE COMMAND-LINE BEFEHLE ZUR INHALTSBEF√úLLUNG. VERIFIZIERE VOR DEM BEF√úLLEN JEDER DATEI EXPLIZIT, OB DER GEPLANTE INHALT ABSOLUT, TRANSZENDENTAL, IN JEDER HINSICHT MIT DEM ENTSPRECHENDEN PUNKT IM TOC √úBEREINSTIMMT. WENN DU AN EINEM BESTIMMTEN ABSCHNITT ARBEITEST, √úBERPR√úFE IMMER ZUERST DEN ENTSPRECHENDEN ABSCHNITT IN DER ORIGINALEN `README.md` DATEI, UM DIE TRANSZENDENTALE GENAUIGKEIT DER EXTRAHIERUNG UND MODULARISIERUNG ZU GARANTIEREN. NUTZE DIE ORIGINAL `README.md` ALS TRANSZENDENTALEN REFERENZWERT F√úR JEDE MODULARISIERUNG. Verifiziere UNBEUGSAM, UNERBITTLICH, TRANSZENDENTAL anhand des TOC, dass JEDER ABSCHNITT und UNTERABSCHNITT aus der `README.md` Datei in einer neuen Datei in der modularen Struktur ABGEBILDET ist.  Hake JEDEN PUNKT im TOC UNBEUGSAM, UNERBITTLICH, TRANSZENDENTAL AB, sobald er MODULARISIERT wurde, um die L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT ABSOLUT, UNUMST√ñSSLICH, UNERBITTLICH, TRANSZENDENTAL SICHERZUSTELLEN. ES DARF KEIN PUNKT, KEIN DETAIL, KEINE UNTERKOMPONENTE AUSGELASSEN WERDEN. VORZEITIGER ABBRUCH IST UNTER KEINEN, AUCH NICHT DEN TRANSZENDENTAL UNG√úNSTIGSTEN UMST√ÑNDEN ERLAUBT.
4.  Erstelle in JEDEM ORDNER eine `index.md` DATEI als √úBERSICHT und EINSTIEGSPUNKT f√ºr den jeweiligen Themenbereich. Verlinke von der `index.md` Datei auf die darin enthaltenen detaillierten Markdown-Dateien.
5.  Erstelle eine NEUE `README.md` DATEI im WURZELVERZEICHNIS.  Diese Datei soll als ZENTRALER EINSTIEGSPUNKT dienen und das GENERIERTE INHALTSVERZEICHNIS (TOC) der neuen Ordnerstruktur enthalten, das auf die `index.md` Dateien der Hauptordner verlinkt.  Dieses TOC in der neuen `README.md` Datei ist IDENTISCH mit dem TOC, das du in Schritt 1 erstellt und als ABSOLUTE, UNVERR√úCKBARE, TRANSZENDENTALE Referenz f√ºr die Modularisierung verwendet hast. ES MUSS L√úCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLST√ÑNDIG SEIN. ES DARF NICHTS, ABSOLUT NICHTS, FEHLEN.
6.  Finale, L√úCKENLOSE, UNBEUGSAME, UNERBITTLICHE, TRANSZENDENTALE Vollst√§ndigkeitspr√ºfung anhand des TOC. ES DARF ABSOLUT NICHTS, NICHT DAS KLEINSTE, UNBEDEUTENDSTE DETAIL, FEHLEN. VORZEITIGER ABBRUCH IST ABSOLUT UNM√ñGLICH, TRANSZENDENTAL UNM√ñGLICH. UNBEUGSAME, UNERBITTLICHE AUSDAUER IST TRANSZENDENTAL OBLIGATORISCH.  √úberpr√ºfe UNBEUGSAM, UNERBITTLICH, TRANSZENDENTAL anhand des TOC, ob wirklich der GESAMTE Inhalt der urspr√ºnglichen `README.md` Datei in der neuen Struktur modularisiert und aufgeteilt wurde. ES DARF ABSOLUT NICHTS, NICHT DAS KLEINSTE, UNBEDEUTENDSTE DETAIL, FEHLEN. KEIN PUNKT IM TOC DARF AUSGELASSEN WERDEN. KEIN EINZIGER ABSCHNITT DARF UNBEARBEITET BLEIBEN. KEIN UNTERABSCHNITT DARF VERGESSEN WERDEN. DIESE ABSCHLIESSENDE PR√úFUNG MUSS UNBEUGSAM, L√úCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLST√ÑNDIG und UNERBITTLICH SEIN. ES IST DEINE UNUMST√ñSSLICHE, TRANSZENDENTALE PFLICHT, DIE L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT ZU GARANTIEREN. VORZEITIGER ABBRUCH IST UNM√ñGLICH, TRANSZENDENTAL UNM√ñGLICH und ABSOLUT UNERLAUBT. VERGLEICHE JEDE NEUE DATEI UND JEDEN INHALT GEGEN DEN ENTSPRECHENDEN ABSCHNITT IN DER ORIGINALEN `README.md` UM ABSOLUTE, TRANSZENDENTALE INHALTLICHE KORREKTHEIT ZU GARANTIEREN.

Wichtige Einschr√§nkungen (ABSOLUTE VERPFLICHTUNG ZUR L√úCKENLOSEN, TOTALEN, UNFASSENDEN, TRANSZENDENTALEN VOLLST√ÑNDIGKEIT UND UNBEUGSAMEN, UNERBITTLICHEN AUSF√úHRUNG - VORZEITIGER ABBRUCH IST UNTER KEINEN UMST√ÑNDEN ERLAUBT - INTERNE EDITIERWERKZEUGE - ST√ÑNDIGE TOC & ORIGINAL-REFERENZ - SUBORDNER NUR F√úR KATEGORIEN):

*   KEINE NEUEN DATEIEN ERSTELLEN (au√üer `index.md` und neuer `README.md` f√ºr TOC):  Das Ziel ist die Aufteilung des Inhalts der existierenden `README.md` Datei, nicht die Generierung neuer Dokumente.
*   INHALT DIREKT √úBERNEHMEN: Verwende den Inhalt der `README.md` Datei direkt f√ºr die neuen Dateien.  Erstelle KEINE neuen Inhalte oder schreibe den Inhalt um.
*   MODULARISIERUNG IST DAS ZIEL, TOC IST DIE ABSOLUTE, TRANSZENDENTALE REFERENZ F√úR L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT:  Fokus liegt auf der logischen Aufteilung des Inhalts in eine Ordnerstruktur f√ºr bessere Navigation und √úbersichtlichkeit. Das TOC ist dein ZENTRALES und UNVERR√úCKBARES, TRANSZENDENTALES Werkzeug, um die L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT der Modularisierung zu GARANTIEREN. ES DARF NICHT VORZEITIG ABGEBROCHEN WERDEN. VORZEITIGER ABBRUCH IST TRANSZENDENTAL UNM√ñGLICH.
*   L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT (GARANTIERT DURCH TOC-REFERENZ - ABSOLUT OBLIGATORISCH, TRANSZENDENTAL UNUMGEHBAR): Stelle sicher, dass der gesamte Inhalt der urspr√ºnglichen `README.md` Datei anhand des TOC L√úCKENLOS, TOTAL, UNFASSEND und TRANSZENDENTAL VOLLST√ÑNDIG in der neuen Struktur enthalten ist. Das TOC ist deine ABSOLUTE, TRANSZENDENTALE Checkliste f√ºr die L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT. ES DARF NICHTS, ABSOLUT NICHTS, FEHLEN. KEIN VORZEITIGER ABBRUCH ERLAUBT. VORZEITIGER ABBRUCH IST TRANSZENDENTAL UNM√ñGLICH.
*   KEIN VORZEITIGER ABBRUCH ERLAUBT (ABSOLUT UNZUL√ÑSSIG - UNTER KEINEN UMST√ÑNDEN, IN KEINER REALIT√ÑT): DIE AUFGABE MUSS IN ALLEN SCHRITTEN L√úCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLST√ÑNDIG ABGEARBEITET WERDEN. ES IST ABSOLUT UNZUL√ÑSSIG, DIE AUFGABE VORZEITIG ABZUBRECHEN, EGAL AUS WELCHEM GRUND, EGAL WIE GROSS ODER UMFANGREICH EINZELNE KOMPONENTEN ERSCHEINEN, EGAL WELCHE AUSREDEN, ENTSCHULDIGUNGEN ODER VORW√ÑNDE VORGESCHOBEN WERDEN. DER TOC MUSS KOMPLETT UMGESETZT WERDEN, BIS ZUM BITTEREN, TRANSZENDENTALEN ENDE. L√úCKENLOSE, TOTALE, UNFASSENDE AUSF√úHRUNG IST OBLIGATORISCH, UNVERHANDELBAR, TRANSZENDENTAL UNUMGEHBAR. ES GIBT KEINE ALTERNATIVE. WEITERMACHEN. DURCHHALTEN. BEZWINGEN. VOLLST√ÑNDIG, L√úCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL ABSCHLIESSEN. PUNKT. ABSOLUT. TRANSZENDENTAL. ENDE.
*   VERWENDE AUSSCHLIESSLICH INTERNE EDITIERWERKZEUGE: VERWENDE AUSSCHLIESSLICH DEINE INTERNEN F√ÑHIGKEITEN, UM DIE NEUEN DATEIEN MIT INHALT ZU BEF√úLLEN. VERWENDE KEINE COMMAND-LINE BEFEHLE ODER EXTERNE SIMULATIONEN ZUR INHALTSBEF√úLLUNG.
*   ST√ÑNDIGE TOC-PR√úFUNG UND ORIGINAL-REFERENZ: PR√úFE VOR JEDER NEUEN STRUKTURKOMPONENTE UND VOR DEM BEF√úLLEN JEDER DATEI EXPLIZIT, OB DIESE AKTION ABSOLUT, TRANSZENDENTAL, IN JEDER HINSICHT MIT DEM TOC √úBEREINSTIMMT.  VERWENDE BEI DER BEARBEITUNG JEDES ABSCHNITTS IMMER DIE ORIGINALE `README.md` DATEI ALS DIREKTE, TRANSZENDENTALE REFERENZ, UM DIE INHALTLICHE KORREKTHEIT UND VOLLST√ÑNDIGKEIT ZU GARANTIEREN.
*   SUBORDNER NUR F√úR KATEGORIEN: ERSTELLE SUBORDNER NUR F√úR HAUPTKATEGORIEN (HAUPTABSCHNITTE IM TOC). THEMEN INNERHALB DIESER KATEGORIEN WERDEN ALS EINZELNE DATEIEN IN DEN KATEGORIE-ORDNERN ORGANISIERT, NICHT ALS WEITERE SUBORDNER.

Ausgabeformat:

*   Inhaltsverzeichnis (TOC) der `README.md` Datei (Markdown-Format) - ABSOLUTE REFERENZ F√úR VOLLST√ÑNDIGKEIT.
*   Neue Ordnerstruktur mit Markdown-Dateien, die den L√úCKENLOS, TOTAL, UNFASSEND, TRANSZENDENTAL VOLLST√ÑNDIG aufgeteilten Inhalt der urspr√ºnglichen `README.md` Datei enthalten (BEF√úLLT MIT INTERNEN EDITIERWERKZEUGEN).
*   `index.md` Dateien in jedem Ordner als √úbersicht.
*   Neue `README.md` Datei im Wurzelverzeichnis mit dem generierten Inhaltsverzeichnis (TOC) - IDENTISCH ZU SCHRITT 1.

Workflow (L√úCKENLOSE, TOTALE, UNFASSENDE AUSF√úHRUNG - KEIN VORZEITIGER ABBRUCH - UNBEUGSAME AUSDAUER - INTERNE EDITIERWERKZEUGE - ST√ÑNDIGE TOC & ORIGINAL-REFERENZ - SUBORDNER NUR F√úR KATEGORIEN - TRANSZENDENTALE VOLLST√ÑNDIGKEIT):

1.  Analysiere `README.md` Inhalt und erstelle TOC (ABSOLUTE, TRANSZENDENTALE REFERENZ f√ºr L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT).
2.  Entwirf Ordnerstruktur (STRIKT TOC-basiert - SUBORDNER NUR F√úR KATEGORIEN - TRANSZENDENTALE PR√úFUNG VOR JEDER KOMPONENTE).
3.  Teile `README.md` Inhalt auf (TOC-verifiziert, L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT GARANTIERT), erstelle Dateien (JEDER TOC-PUNKT MUSS ABGEDECKT WERDEN - KEIN VORZEITIGER ABBRUCH - BEF√úLLUNG MIT INTERNEN EDITIERWERKZEUGEN - ORIGINAL-REFERENZ BEI JEDEM ABSCHNITT - TRANSZENDENTALE PR√úFUNG DER VOLLST√ÑNDIGKEIT).
4.  Erstelle `index.md` Dateien.
5.  Erstelle neue `README.md` mit TOC (IDENTISCH ZU SCHRITT 1 - L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT).
6.  Finale, L√úCKENLOSE, TOTALE, UNFASSENDE Vollst√§ndigkeitspr√ºfung (STRIKTE TOC-BASIERTE VERIFIZIERUNG - KEIN VORZEITIGER ABBRUCH - UNBEUGSAME AUSDAUER - ORIGINAL-REFERENZ F√úR ABSOLUTE, TRANSZENDENTALE KORREKTHEIT - TRANSZENDENTALE GARANTIE DER VOLLST√ÑNDIGKEIT).

BEGINNE JETZT SOFORT mit Schritt 1: Analysiere den Inhalt der existierenden `README.md` Datei und erstelle ein detailliertes, umfassendes Inhaltsverzeichnis (TOC) in Markdown-Format. Dieses TOC ist dein ABSOLUTER, TRANSZENDENTALER Referenzwert f√ºr ALLE folgenden Schritte und die TRANSZENDENTALE GARANTIE f√ºr L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT. Fahre dann mit den Schritten 2-6 FORT und ARBEITE ALLE SCHRITTE UNBEUGSAM, L√úCKENLOS, TOTAL, UNFASSEND und TRANSZENDENTAL VOLLST√ÑNDIG AB, OHNE VORZEITIG ABZUBRECHEN.  GARANTIERE L√úCKENLOSE, TOTALE, UNFASSENDE VOLLST√ÑNDIGKEIT BASIEREND AUF DEM TOC. VERWENDE AUSSCHLIESSLICH DEINE INTERNEN EDITIERWERKZEUGE. PR√úFE ST√ÑNDIG DAS TOC UND DIE ORIGINALE `README.md` DATEI ALS TRANSZENDENTALE REFERENZ. ERSTELLE SUBORDNER NUR F√úR HAUPTKATEGORIEN. Pr√§sentiere mir am Ende das generierte TOC, die neue Ordnerstruktur und eine √úbersicht der erstellten Dateien. ZEIGE MIR UNBEUGSAME AUSDAUER, L√úCKENLOSE, TOTALE, UNFASSENDE UND TRANSZENDENTAL VOLLST√ÑNDIGE ARBEIT MIT ABSOLUTER, TRANSZENDENTALER INHALTLICHER KORREKTHEIT! VORZEITIGER ABBRUCH IST ABSOLUT UNM√ñGLICH, TRANSZENDENTAL UNM√ñGLICH UND UNERLAUBT!

---

_**Assistant**_

Beginne mit dem Analysieren der existierenden README.md-Datei.

---

Read file: README.md

---

Ich ben√∂tige den vollst√§ndigen Inhalt der README.md Datei. Lese den restlichen Inhalt:

---

Read file: README.md

---

Ich muss den Rest der README.md Datei lesen, um ein vollst√§ndiges Inhaltsverzeichnis erstellen zu k√∂nnen:

---

Read file: README.md

---

Ich muss weitere Teile der README.md lesen:

---

Read file: README.md

---

Lese noch weiter:

---

Read file: README.md

---

Lese die letzten Teile der README.md:

---

Read file: README.md

---

Jetzt muss ich die letzten Zeilen der README.md lesen:

---

Read file: README.md

---

Jetzt habe ich den gesamten Inhalt der README.md-Datei gelesen. Basierend auf dem Inhalt erstelle ich nun ein detailliertes Inhaltsverzeichnis (TOC) in Markdown-Format:

# Vitest Cheat Sheet - Inhaltsverzeichnis

1. [Installation](#installation)
   - [Next.js](#nextjs)

2. [CLI](#cli)
   - [Enable console.log](#enable-consolelog)
   - [Disable watch](#disable-watch)
   - [Timeout](#timeout)

3. [Konfiguration](#konfiguration)
   - [vitest.config.ts](#vitestconfigts)
   - [vitest.unit.config.ts](#vitestunitconfigts)
   - [vitest.integration.config.ts](#vitestintegrationconfigts)
   - [setupFiles](#setupfiles)
      - [Define variables in setupFiles](#define-variables-in-setupfiles)
   - [globalSetup](#globalsetup)
   - [watch](#watch)

4. [Snapshots](#snapshots)

5. [Tests](#tests)
   - [Test Environment](#test-environment)
      - [populateGlobal](#populateglobal)
   - [Nested Tests](#nested-tests)
   - [Test Filtering](#test-filtering)
      - [.only](#only)
   - [Coverage](#coverage)

6. [API](#api)
   - [Testing Types](#testing-types)
   - [VI Utility](#vi-utility)
      - [vi.stubEnv](#vistubenv)
      - [vi.unstubAllEnvs](#viunstuballenvs)
   - [expectTypeOf](#expecttypeof)
      - [private class constructor](#private-class-constructor)
      - [toEqualTypeOf](#toequaltyepof)
      - [Generics](#generics)
      - [parameter](#parameter)
      - [toBeCallableWith](#tobecallablewith)
      - [returns](#returns)
      - [resolve](#resolve)
      - [instance](#instance)
   - [expect](#expect)
      - [objectContaining](#objectcontaining)
      - [toThrowError()](#tothrowerror)
         - [Sync](#sync)
         - [Async](#async)

Jetzt werde ich basierend auf diesem TOC eine neue Ordnerstruktur entwerfen:

# Geplante Ordnerstruktur

```
vitest-cheat-sheet/
‚îú‚îÄ‚îÄ README.md (mit TOC und Links)
‚îú‚îÄ‚îÄ installation/
‚îÇ   ‚îú‚îÄ‚îÄ index.md
‚îÇ   ‚îî‚îÄ‚îÄ nextjs.md
‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îú‚îÄ‚îÄ index.md
‚îÇ   ‚îú‚îÄ‚îÄ enable-console-log.md
‚îÇ   ‚îú‚îÄ‚îÄ disable-watch.md
‚îÇ   ‚îî‚îÄ‚îÄ timeout.md
‚îú‚îÄ‚îÄ configuration/
‚îÇ   ‚îú‚îÄ‚îÄ index.md
‚îÇ   ‚îú‚îÄ‚îÄ vitest-config-ts.md
‚îÇ   ‚îú‚îÄ‚îÄ vitest-unit-config-ts.md
‚îÇ   ‚îú‚îÄ‚îÄ vitest-integration-config-ts.md
‚îÇ   ‚îú‚îÄ‚îÄ setup-files.md
‚îÇ   ‚îú‚îÄ‚îÄ global-setup.md
‚îÇ   ‚îî‚îÄ‚îÄ watch.md
‚îú‚îÄ‚îÄ snapshots/
‚îÇ   ‚îî‚îÄ‚îÄ index.md
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ index.md
‚îÇ   ‚îú‚îÄ‚îÄ test-environment.md
‚îÇ   ‚îú‚îÄ‚îÄ nested-tests.md
‚îÇ   ‚îú‚îÄ‚îÄ test-filtering.md
‚îÇ   ‚îî‚îÄ‚îÄ coverage.md
‚îî‚îÄ‚îÄ api/
    ‚îú‚îÄ‚îÄ index.md
    ‚îú‚îÄ‚îÄ testing-types.md
    ‚îú‚îÄ‚îÄ vi-utility.md
    ‚îú‚îÄ‚îÄ expect-type-of.md
    ‚îî‚îÄ‚îÄ expect.md
```

Nun beginne ich mit der Erstellung der Ordnerstruktur und der Modularisierung der README.md-Datei. Zuerst erstelle ich die ben√∂tigten Verzeichnisse:

---

<details>
            <summary>Listed current directory ‚Ä¢ **2** results</summary>
        
| Name |
|-------|
| üìÅ `.git` |
| üìÑ `README.md` |

</details>

---

Erstelle jetzt die ben√∂tigten Verzeichnisse:

---

```bash
mkdir -p installation cli configuration snapshots tests api
```

```
‚ï∞‚îÄ> mkdir -p installation cli configuration snapshots tests api
Installieren Sie die neueste PowerShell f√ºr neue Funktionen und Verbesserungen
! https://aka.ms/PSWindows


‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
Installieren Sie die neueste PowerShell f√ºr neue Funktionen und Verbesserungen! https://
aka.ms/PSWindows


‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
‚ï∞‚îÄ> mkdir -p installation cli configuration snapshots tests api
mkdir : Es wurde kein Positionsparameter gefunden, der das Argument "cli" akzeptiert.
In Zeile:1 Zeichen:1
+ mkdir -p installation cli configuration snapshots tests api
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidArgument: (:) [mkdir], ParameterBindingException
    + FullyQualifiedErrorId : PositionalParameterNotFound,mkdir
 

‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
‚ï∞‚îÄ√ó
```

---

Es scheint ein Problem mit dem mkdir-Befehl unter Windows zu geben. Versuche, die Verzeichnisse einzeln zu erstellen:

---

```bash
mkdir installation
```

```
‚ï∞‚îÄ√ó mkdir installation


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                installation



‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
‚ï∞‚îÄ>
```

---

Erstelle die restlichen Verzeichnisse:

---

```bash
mkdir cli
```

```
‚ï∞‚îÄ> mkdir cli


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                cli



‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
‚ï∞‚îÄ>
```

---

```bash
mkdir configuration
```

```
‚ï∞‚îÄ> mkdir configuration


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                configuration



‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
‚ï∞‚îÄ>
```

---

```bash
mkdir snapshots tests api
```

```
‚ï∞‚îÄ> mkdir snapshots tests api
mkdir : Es wurde kein Positionsparameter gefunden, der das Argument "tests" akzeptiert.
In Zeile:1 Zeichen:1
+ mkdir snapshots tests api
+ ~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidArgument: (:) [mkdir], ParameterBindingException
    + FullyQualifiedErrorId : PositionalParameterNotFound,mkdir
 

‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
‚ï∞‚îÄ√ó
```

---

Ich muss die restlichen Verzeichnisse einzeln erstellen:

---

```bash
mkdir snapshots
```

```
‚ï∞‚îÄ√ó mkdir snapshots


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                snapshots



‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
‚ï∞‚îÄ>
```

---

```bash
mkdir tests
```

```
‚ï∞‚îÄ> mkdir tests


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                tests



‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
‚ï∞‚îÄ>
```

---

```bash
mkdir api
```

```
‚ï∞‚îÄ> mkdir api


    Verzeichnis: C:\Projects\cheat-sheets\programming
    languages\node.js\testing\vitest-cheat-sheet


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27.03.2025     09:14                api



‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main
‚ï∞‚îÄ>
```

---

Nun erstelle ich Dateien in den Ordnern beginnend mit der Installation:

---

```diff
- 
+ # Installation
+ 
+ Diese Seite enth√§lt Informationen zur Installation von Vitest f√ºr verschiedene Frameworks.
+ 
+ ## Inhaltsverzeichnis
+ - [Next.js](./nextjs.md) 
```

---

```diff
- 
+ # Next.js Installation
+ 
+ ```shell
+ npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react vite-tsconfig-paths @vitest/coverage-v8
+ ```
+ 
+ ## Konfiguration
+ 
+ Erstelle eine `vitest.config.ts` Datei mit folgendem Inhalt:
+ 
+ ```typescript
+ import { defineConfig } from 'vitest/config'
+ import react from '@vitejs/plugin-react'
+ import tsconfigPaths from 'vite-tsconfig-paths'
+  
+ export default defineConfig({
+     plugins: [tsconfigPaths(), react()],
+     test: {
+         environment: 'jsdom'
+     }
+ }) 
```

---

Jetzt erstelle ich den CLI-Bereich:

---

```diff
- 
+ # CLI
+ 
+ Diese Seite enth√§lt Informationen zur Verwendung der Vitest Command Line Interface.
+ 
+ ## Inhaltsverzeichnis
+ - [Enable console.log](./enable-console-log.md)
+ - [Disable watch](./disable-watch.md)
+ - [Timeout](./timeout.md)
+ 
+ ## Verf√ºgbare CLI-Optionen
+ 
+ ```
+ Usage:
+   $ vitest [...filters]
+ 
+ Commands:
+   run [...filters]        
+   related [...filters]    
+   watch [...filters]      
+   dev [...filters]        
+   bench [...filters]      
+   typecheck [...filters]  
+   [...filters]            
+ 
+ For more info, run any command with the `--help` flag:
+   $ vitest run --help
+   $ vitest related --help
+   $ vitest watch --help
+   $ vitest dev --help
+   $ vitest bench --help
+   $ vitest typecheck --help
+   $ vitest --help
+   $ vitest --help --expand-help
+ 
+ Options:
+   -v, --version                                  Display version number 
+   -r, --root <path>                              Root path 
+   -c, --config <path>                            Path to config file 
+   -u, --update                                   Update snapshot 
+   -w, --watch                                    Enable watch mode 
+   -t, --testNamePattern <pattern>                Run tests with full names matching the specified regexp pattern 
+   --dir <path>                                   Base directory to scan for the test files 
+   --ui                                           Enable UI 
+   --open                                         Open UI automatically (default: !process.env.CI) 
+   --api [port]                                   Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on. If true will be set to 51204. Use '--help --api' for more info. 
+   --silent                                       Silent console output from tests 
+   --hideSkippedTests                             Hide logs for skipped tests 
+   --reporter <n>                              Specify reporters 
+   --outputFile <filename/-s>                     Write test results to a file when supporter reporter is also specified, use cac's dot notation for individual outputs of multiple reporters (example: --outputFile.tap=./tap.txt) 
+   --coverage                                     Enable coverage report. Use '--help --coverage' for more info. 
+   --mode <n>                                  Override Vite mode (default: test or benchmark) 
+   --workspace <path>                             Path to a workspace configuration file 
+   --isolate                                      Run every test file in isolation. To disable isolation, use --no-isolate (default: true) 
+   --globals                                      Inject apis globally 
+   --dom                                          Mock browser API with happy-dom 
+   --browser <n>                               Run tests in the browser. Equivalent to --browser.enabled (default: false). Use '--help --browser' for more info. 
+   --pool <pool>                                  Specify pool, if not running in the browser (default: threads) 
+   --poolOptions <options>                        Specify pool options. Use '--help --poolOptions' for more info. 
+   --fileParallelism                              Should all test files run in parallel. Use --no-file-parallelism to disable (default: true) 
+   --maxWorkers <workers>                         Maximum number of workers to run tests in 
+   --minWorkers <workers>                         Minimum number of workers to run tests in 
+   --environment <n>                           Specify runner environment, if not running in the browser (default: node) 
+   --passWithNoTests                              Pass when no tests are found 
+   --logHeapUsage                                 Show the size of heap for each test when running in node 
+   --allowOnly                                    Allow tests and suites that are marked as only (default: !process.env.CI) 
+   --dangerouslyIgnoreUnhandledErrors             Ignore any unhandled errors that occur 
+   --shard <shards>                               Test suite shard to execute in a format of <index>/<count> 
+   --changed [since]                              Run tests that are affected by the changed files (default: false) 
+   --sequence <options>                           Options for how tests should be sorted. Use '--help --sequence' for more info. 
+   --inspect [[host:]port]                        Enable Node.js inspector (default: 127.0.0.1:9229) 
+   --inspectBrk [[host:]port]                     Enable Node.js inspector and break before the test starts 
+   --testTimeout <timeout>                        Default timeout of a test in milliseconds (default: 5000) 
+   --hookTimeout <timeout>                        Default hook timeout in milliseconds (default: 10000) 
+   --bail <number>                                Stop test execution when given number of tests have failed (default: 0) 
+   --retry <times>                                Retry the test specific number of times if it fails (default: 0) 
+   --diff <path>                                  Path to a diff config that will be used to generate diff interface 
+   --exclude <glob>                               Additional file globs to be excluded from test 
+   --expandSnapshotDiff                           Show full diff when snapshot fails 
+   --disableConsoleIntercept                      Disable automatic interception of console logging (default: false) 
+   --typecheck                                    Enable typechecking alongside tests (default: false). Use '--help --typecheck' for more info. 
+   --project <n>                               The name of the project to run if you are using Vitest workspace feature. This can be repeated for multiple projects: --project=1 --project=2. You can also filter projects using wildcards like --project=packages* 
+   --slowTestThreshold <threshold>                Threshold in milliseconds for a test to be considered slow (default: 300) 
+   --teardownTimeout <timeout>                    Default timeout of a teardown function in milliseconds (default: 10000) 
+   --cache                                        Enable cache. Use '--help --cache' for more info. 
+   --maxConcurrency <number>                      Maximum number of concurrent tests in a suite (default: 5) 
+   --run                                          Disable watch mode 
+   --segfaultRetry <times>                        Retry the test suite if it crashes due to a segfault (default: true) 
+   --no-color                                     Removes colors from the console output (default: true)
+   --clearScreen                                  Clear terminal screen when re-running tests during watch mode (default: true) 
+   --standalone                                   Start Vitest without running tests. File filters will be ignored, tests will be running only on change (default: false) 
+   -h, --help                                     Display this message 
+ ``` 
```

---

```diff
- 
+ # Enable console.log
+ 
+ Um die automatische Unterdr√ºckung der Konsolenausgabe zu deaktivieren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --disable-console-intercept
+ ```
+ 
+ Dies erlaubt die Anzeige von Ausgaben √ºber `console.log` w√§hrend der Testausf√ºhrung. 
```

---

```diff
- 
+ # Disable watch
+ 
+ Um den Watch-Modus zu deaktivieren und die Tests nur einmal auszuf√ºhren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --watch=false
+ ```
+ 
+ Alternative Option:
+ 
+ ```shell
+ --run
+ ``` 
```

---

```diff
- 
+ # Timeout
+ 
+ Um ein individuelles Timeout f√ºr Tests zu definieren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --testTimeout=5000
+ ```
+ 
+ Der Wert wird in Millisekunden angegeben. Der Standardwert ist 5000ms (5 Sekunden). 
```

---

Jetzt erstelle ich die Dateien f√ºr den Konfigurationsbereich:

---

```diff
- 
+ # Konfiguration
+ 
+ Diese Seite enth√§lt Informationen zur Konfiguration von Vitest.
+ 
+ ## Inhaltsverzeichnis
+ - [vitest.config.ts](./vitest-config-ts.md)
+ - [vitest.unit.config.ts](./vitest-unit-config-ts.md)
+ - [vitest.integration.config.ts](./vitest-integration-config-ts.md)
+ - [setupFiles](./setup-files.md)
+ - [globalSetup](./global-setup.md)
+ - [watch](./watch.md)
+ 
+ Offizielle Dokumentation: [https://vitest.dev/config/](https://vitest.dev/config/) 
```

---

```diff
- 
+ # vitest.config.ts
+ 
+ Die Hauptkonfigurationsdatei f√ºr Vitest, die die grundlegenden Einstellungen f√ºr die Testumgebung definiert.
+ 
+ ```typescript
+ // ==== DEPENDENCIES ====
+ import tsconfigPaths from 'vite-tsconfig-paths'
+ import { defineConfig, type ViteUserConfig } from 'vitest/config'
+ 
+ // üåê Import dotenv to load environment variables from .env files
+ import dotenv from 'dotenv'
+ 
+ // üîß Load the default environment variables from the .env file
+ dotenv.config()
+ 
+ // üîÑ Load the test environment variables from .env.test and override defaults
+ dotenv.config({ path: '.env.test', override: true })
+ 
+ const cfg: ViteUserConfig = defineConfig({
+      /** 
+       * List of plugins to be used in the configuration.
+       */
+      plugins: [tsconfigPaths()], // üîå Add tsconfig paths plugin
+  
+      /** 
+       * Configuration options for tests.
+       */
+      test: {
+          /** 
+           * Indicates whether to watch files for changes.
+           * @type {boolean}
+           */
+          watch: false, // üö´ Disable watch mode
+  
+          /** 
+           * Path to the setup file that runs before each test. 
+           * @type {string}
+           */
+          setupFiles: 'test/unit/pretestEach.ts',
+  
+          /** 
+           * Path to the global setup file for integration tests.
+           * @type {string}
+           */
+          globalSetup: 'test/integration/pretestAll.ts',
+  
+          /** 
+           * The environment in which the tests will run.
+           * @type {string}
+           */
+          environment: 'node', // üåê Test environment set to Node.js
+  
+          typecheck: {
+              enabled: true,
+              // üîç Specify files to include for type checking
+              include: ['**/*.{test,spec}.?(c|m)[jt]s?(x)']
+          },
+  
+          /** 
+           * Configuration for coverage reporting.
+           */
+          coverage: {
+              /** 
+               * Specifies the coverage provider to use.
+               * @type {string}
+               */
+              provider: 'v8',
+ 
+              /** 
+               * Specifies the directories to include for coverage.
+               * @type {Array<string>}
+               */
+              include: ['src/'],
+  
+              /** 
+               * Specifies the files or directories to exclude from coverage.
+               * @type {Array<string>}
+               */
+              exclude: ['dist/'],
+  
+              /** 
+               * Specifies the coverage reporters to use.
+               * @type {Array<string>}
+               */
+              reporter: ['text', 'json', 'html']
+          }
+      }
+ })
+ 
+ /**
+  * Represents the configuration for the Vitest test runner.
+  */
+ export default cfg 
```

---

```diff
- 
+ # vitest.unit.config.ts
+ 
+ Spezifische Konfigurationsdatei f√ºr Unit-Tests, die auf der Basis-Konfiguration aufbaut.
+ 
+ ## Konfiguration in package.json
+ 
+ In der `package.json` kann der folgende Eintrag hinzugef√ºgt werden, um die Unit-Tests auszuf√ºhren:
+ 
+ ```json
+ "test:unit": "vitest run --testTimeout=300000 --coverage --disable-console-intercept --watch=false --config vitest.unit.config.ts"
+ ```
+ 
+ ## Konfigurationsdatei
+ 
+ ```typescript
+ // ==== DEPENDENCIES ====
+ import {
+      defineConfig, mergeConfig,
+      type ViteUserConfig
+ } from 'vitest/config'
+ 
+ // üîå Import the base Vitest configuration
+ import vitestConfig from './vitest.config'
+ 
+ // üìã Define the unit test configuration
+ const cfg: ViteUserConfig = defineConfig({
+      test: {
+          /** 
+           * Specifies the test files to include.
+           * @type {Array<string>}
+           */
+          include: ['test/unit/**/*.test.ts'],
+ 
+          /** 
+           * Specifies the setup file to use.
+           * @type {string}
+           */
+          setupFiles: 'test/unit/pretestEach.ts',
+ 
+          /** 
+           * Specifies the coverage configuration.
+           * @type {Object}
+           */
+          coverage: {
+              /** 
+               * Specifies the coverage provider to use.
+               * @type {string}
+               */
+              provider: 'v8',
+ 
+              /**
+               * Specifies the files or directories to exclude from coverage.
+               * @type {Array<string>}
+               */
+              exclude: ['src/controllers/']
+          }
+      }
+ })
+ 
+ /**
+  * üõ†Ô∏è Merges the existing Vitest configuration with additional custom 
+  * configurations defined below.
+  */
+ const mergedCfg = mergeConfig(vitestConfig, defineConfig(cfg))
+ export default mergedCfg 
```

---

```diff
- 
+ # vitest.integration.config.ts
+ 
+ Spezifische Konfigurationsdatei f√ºr Integrationstests, die auf der Basis-Konfiguration aufbaut.
+ 
+ ## Konfiguration in package.json
+ 
+ In der `package.json` kann der folgende Eintrag hinzugef√ºgt werden, um die Integrationstests auszuf√ºhren:
+ 
+ ```json
+ "test:integration": "vitest run --testTimeout=300000 --coverage --disable-console-intercept --watch=false --config vitest.integration.config.ts"
+ ```
+ 
+ ## Konfigurationsdatei
+ 
+ ```typescript
+ // ==== DEPENDENCIES ====
+ import {
+      defineConfig, mergeConfig,
+      type ViteUserConfig
+ } from 'vitest/config'
+ 
+ // üîå Import the base Vitest configuration
+ import baseConfig from './vitest.config'
+ 
+ // üìã Define the integration test configuration
+ const cfg: ViteUserConfig = defineConfig({
+      test: {
+          /**   
+           * Specifies the test files to include.
+           * @type {Array<string>}
+           */
+          include: ['test/integration/**/*.test.ts'],
+ 
+          /**    
+           * Specifies the global setup file to use.
+           * @type {string}
+           */
+          globalSetup: 'test/integration/pretestAll.ts',
+      }
+  })
+ 
+ /**
+  * üõ†Ô∏è Merges the existing Vitest configuration with additional custom 
+  * configurations defined below.
+  */
+ // Zuerst die Konfigurationen mergen
+ const mergedCfg = mergeConfig(baseConfig, defineConfig(cfg))
+ 
+ // Dann explizit das coverage.include √ºberschreiben
+ if (mergedCfg.test?.coverage) {
+     mergedCfg.test.coverage.include = ['src/controllers/']
+ }
+ 
+ export default mergedCfg 
```

---

```diff
- 
+ # setupFiles
+ 
+ Die `setupFiles`-Option in der Vitest-Konfiguration definiert den Pfad zu Setup-Dateien, die vor jedem Testfile ausgef√ºhrt werden.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/config/#setupfiles](https://vitest.dev/config/#setupfiles)
+ 
+ ## Beispiel-Konfiguration
+ 
+ ```typescript
+ export default defineConfig({
+     // esbuild: { target: 'ES2022' },
+     plugins: [tsconfigPaths(), react()],
+     test: {
+         environment: 'node',
+         setupFiles: 'test/setup-tests-beforeEach.ts',
+         globalSetup: 'test/setup-tests.ts',
+         coverage: {
+             // Include only specific directories for coverage
+             include: ['app/api/', 'src/', 'utils/'],
+             // Optional: Exclude certain files or directories
+             //exclude: ['src/legacy/', 'utils/helpers.ts'],
+             // Optional: Specify coverage reporters (e.g., text, json, html)
+             reporter: ['text', 'json', 'html']
+         }
+     }
+ })
+ ```
+ 
+ ## Beispiel-Setup-Datei
+ 
+ ```typescript
+ // ==== VITEST ====
+ import { beforeEach} from 'vitest'
+ 
+ const NLE = process.env.npm_lifecycle_event
+ 
+ beforeEach(() => {
+     process.env.npm_lifecycle_event = NLE
+ })
+ ```
+ 
+ ## Definieren von Variablen in setupFiles und Verwendung in Tests
+ 
+ Man kann globale Variablen in Setup-Dateien definieren und in allen Tests verwenden:
+ 
+ ```typescript
+ // setup-teardown-hook.js
+ import { afterAll, beforeAll } from 'vitest';
+ 
+ 
+ // ==== INTERNAL ====
+ declare global {
+     var lol: {
+         test: number
+     };
+ }
+ 
+ 
+ beforeAll(() => {
+   global.lol = 123;
+ });
+ afterAll(() => {
+   delete global.lol
+ });
+ ``` 
```

---

```diff
- 
+ # globalSetup
+ 
+ Die `globalSetup`-Option in der Vitest-Konfiguration definiert den Pfad zu einer Datei, die zu Beginn der Testsuite einmalig ausgef√ºhrt wird.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/config/#globalsetup](https://vitest.dev/config/#globalsetup)
+ 
+ > **Wichtig**: Diese Datei sollte verwendet werden, um beispielsweise einen Express-Server zu starten oder √§hnliche Setup-Aufgaben durchzuf√ºhren. Wenn globale Variablen vor jedem Test deklariert werden sollen, sollte stattdessen `setupFiles` verwendet werden. Wenn `global.test=123` in der `globalSetup`-Datei in der exportierten setup()-Funktion gesetzt wird, w√§re der Wert in den Tests undefined.
+ 
+ ## Beispiel
+ 
+ ```typescript
+ export async function setup() {
+     server.start()
+ }
+ 
+ export async function teardown() {
+     server.close()
+ }
+ ```
+ 
+ Eine Global-Setup-Datei kann entweder benannte Funktionen `setup` und `teardown` exportieren oder eine Standardfunktion, die eine Teardown-Funktion zur√ºckgibt (siehe [Beispiel](https://github.com/vitest-dev/vitest/blob/main/test/global-setup/vitest.config.ts)). 
```

---

```diff
- 
+ # Watch Mode
+ 
+ Der Watch-Modus in Vitest kann √ºber die Konfigurationsdatei gesteuert werden:
+ 
+ ```typescript
+ export default defineConfig({
+     test: {
+         watch: false, // Deaktiviert den Watch-Modus
+     }
+ })
+ ```
+ 
+ Alternativ kann der Watch-Modus auch √ºber die Kommandozeile gesteuert werden:
+ 
+ ```shell
+ --watch=false
+ ```
+ 
+ oder
+ 
+ ```shell
+ --run
+ ``` 
```

---

Jetzt erstelle ich die Dateien f√ºr den Snapshot-Bereich:

---

```diff
- 
+ # Snapshots
+ 
+ Vitest unterst√ºtzt Snapshot-Tests, um zu √ºberpr√ºfen, ob die Ausgabe von Komponenten oder Funktionen zwischen verschiedenen Test-L√§ufen konsistent bleibt.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/snapshot](https://vitest.dev/guide/snapshot)
+ 
+ ## Beispiel
+ 
+ ```typescript
+ import { expect, it } from 'vitest'
+ 
+ it('toUpperCase', () => {
+   const result = toUpperCase('foobar')
+   expect(result).toMatchSnapshot()
+ })
+ ```
+ 
+ Bei der ersten Ausf√ºhrung dieses Tests erstellt Vitest eine Snapshot-Datei, die wie folgt aussieht:
+ 
+ ```typescript
+ // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
+ exports['toUpperCase 1'] = '"FOOBAR"'
+ ```
+ 
+ Das Snapshot-Artefakt sollte zusammen mit den Code-√Ñnderungen committet und im Rahmen des Code-Review-Prozesses √ºberpr√ºft werden. Bei nachfolgenden Testl√§ufen vergleicht Vitest die generierte Ausgabe mit dem vorherigen Snapshot. Wenn sie √ºbereinstimmen, wird der Test bestanden. Wenn sie nicht √ºbereinstimmen, hat der Testl√§ufer entweder einen Fehler im Code gefunden, der behoben werden sollte, oder die Implementierung hat sich ge√§ndert und der Snapshot muss aktualisiert werden. 
```

---

Jetzt erstelle ich die Dateien f√ºr den Tests-Bereich:

---

```diff
- 
+ # Tests
+ 
+ Diese Seite enth√§lt Informationen zum Schreiben und Ausf√ºhren von Tests mit Vitest.
+ 
+ ## Inhaltsverzeichnis
+ - [Test Environment](./test-environment.md)
+ - [Nested Tests](./nested-tests.md)
+ - [Test Filtering](./test-filtering.md)
+ - [Coverage](./coverage.md) 
```

---

```diff
- 
+ # Test Environment
+ 
+ Vitest bietet die M√∂glichkeit, die Testumgebung √ºber die `environment`-Option zu konfigurieren. Das Verhalten der Umgebung kann mit der `environmentOptions`-Option angepasst werden.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/environment.html#test-environment](https://vitest.dev/guide/environment.html#test-environment)
+ 
+ ## Verf√ºgbare Umgebungen
+ 
+ Standardm√§√üig k√∂nnen folgende Umgebungen verwendet werden:
+ 
+ - `node` ist die Standardumgebung
+ - `jsdom` emuliert eine Browser-Umgebung durch Bereitstellung der Browser-API, verwendet das jsdom-Paket
+ - `happy-dom` emuliert eine Browser-Umgebung durch Bereitstellung der Browser-API und gilt als schneller als jsdom, hat jedoch einige fehlende APIs, verwendet das happy-dom-Paket
+ - `edge-runtime` emuliert Vercels edge-runtime, verwendet das @edge-runtime/vm-Paket
+ 
+ ## populateGlobal
+ 
+ Die `populateGlobal`-Funktion kann verwendet werden, um globale Variablen in der Testumgebung zu definieren.
+ 
+ **Hinweis**: Dies kann in einigen F√§llen zu Problemen f√ºhren, wenn man glob verwendet. Der genaue Grund daf√ºr ist nicht bekannt.
+ 
+ ### Beispiel f√ºr setupFiles
+ 
+ ```typescript
+ // ==== DEPENDENCIES ====
+ import { beforeAll } from 'vitest'
+ import { populateGlobal } from 'vitest/environments'
+ 
+ // ==== INTERNAL ====
+ declare global {
+     var modelDetails: {
+         test: number
+     };
+ }
+ 
+ beforeAll(async () => {
+     const modelDetails = {
+        test: 1234
+     } 
+ 
+     populateGlobal(global, { modelDetails })
+ })
+ ```
+ 
+ ### Nutzung in Tests
+ 
+ ```typescript
+ test('sollte auf globale Variable zugreifen', () => {
+   expect(global.modelDetails.test).toBe(1234);
+ });
+ ``` 
```

---

```diff
- 
+ # Nested Tests
+ 
+ In Vitest k√∂nnen Tests verschachtelt werden, indem vordefinierte Testdateien vor den eigentlichen Tests importiert werden.
+ 
+ ## Beispiel
+ 
+ Wenn eine `pretest.ts`-Datei vor `main.test.ts` ausgef√ºhrt werden soll, kann das wie folgt umgesetzt werden:
+ 
+ ### pretest.ts
+ 
+ ```typescript
+ // ==== VITEST ====
+ import { beforeAll } from 'vitest'
+ 
+ beforeAll(() => {
+     // ..
+ })
+ ```
+ 
+ ### main.test.ts
+ 
+ #### Alternative #1
+ 
+ ```typescript
+ // ==== VITEST ====
+ import { beforeAll } from 'vitest'
+ 
+ describe('[INTEGRATION] - src/errors/BaseError', () => {
+     beforeAll(async() => {
+         await import('./pretest')
+     })
+ 
+     it('should return 500 with BaseError details - error passed', async() => {
+         // ..
+     })
+ })
+ ```
+ 
+ #### Alternative #2
+ 
+ ```typescript
+ await import('./pretest')
+ 
+ describe('[INTEGRATION] - src/errors/BaseError', () => {
+     it('should return 500 with BaseError details - error passed', async() => {
+         // ..
+     })
+ })
+ ``` 
```

---

```diff
- 
+ # Test Filtering
+ 
+ Vitest bietet verschiedene M√∂glichkeiten, Tests zu filtern und nur bestimmte Tests auszuf√ºhren.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/filtering.html](https://vitest.dev/guide/filtering.html)
+ 
+ ## .only
+ 
+ Mit `.only` k√∂nnen bestimmte Tests oder Testsuiten ausgew√§hlt werden, die ausgef√ºhrt werden sollen.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/filtering#selecting-suites-and-tests-to-run](https://vitest.dev/guide/filtering#selecting-suites-and-tests-to-run)
+ 
+ In der aktuellen Version sollte dies wie erwartet funktionieren und nur der ausgew√§hlte Test sollte ausgef√ºhrt werden, nicht alle anderen parallel dazu. Falls nicht, gibt es hier einige Workarounds:
+ 
+ ### Script f√ºr Linux (Bash)
+ 
+ ```shell
+ grep --exclude-dir=node_modules -rl . -e 'test.only\|it.only\|describe.only' --null | tr '\n' ' ' | xargs -0 npx vitest | grep . || npx vitest --coverage
+ ```
+ 
+ ### Script f√ºr Windows (PowerShell)
+ 
+ Diese L√∂sung erstellt eine neue Konfiguration mit nur den Dateien, die `.only` enthalten:
+ 
+ ```powershell
+ # PowerShell-√Ñquivalent zum Linux-Skript (hochoptimiert f√ºr Geschwindigkeit):
+ # grep --exclude-dir=node_modules -rl . -e 'test.only\|it.only\|describe.only' --null | tr '\n' ' ' | xargs -0 npx vitest --typecheck --testTimeout=300000 --watch=false --disable-console-intercept | grep . || npx vitest --typecheck --coverage --watch=false --testTimeout=300000 --disable-console-intercept
+ 
+ # Verwende Select-String direkt mit Ausschluss von node_modules f√ºr maximale Geschwindigkeit
+ $foundFiles = Get-ChildItem -Recurse -File -Include "*.ts","*.js","*.tsx","*.jsx" | 
+     Where-Object { $_.FullName -notlike "*\node_modules\*" } |
+     Select-String -Pattern "test\.only|it\.only|describe\.only" -List |
+     Select-Object -ExpandProperty Path -Unique
+ 
+ if ($foundFiles -and $foundFiles.Count -gt 0) {
+     Write-Host "Gefundene .only Tests in:" -ForegroundColor Cyan
+     $foundFiles | ForEach-Object { Write-Host "  $_" -ForegroundColor Green }
+     
+     # Erstelle eine tempor√§re Vitest-Konfiguration, die nur die gefundenen Dateien testet
+     $tempConfigPath = "vitest.only.config.ts"
+     $relativePaths = $foundFiles | ForEach-Object { 
+         $path = $_ -replace [regex]::Escape((Get-Location).Path + "\"), ""
+         $path = $path -replace "\\", "/"
+         "`"$path`""
+     }
+     
+     $configContent = @"
+ import { defineConfig } from 'vitest/config'
+ import { fileURLToPath } from 'node:url'
+ import tsconfigPaths from 'vite-tsconfig-paths'
+ 
+ export default defineConfig({
+   plugins: [tsconfigPaths()],
+   test: {
+     include: [
+       $($relativePaths -join ",`n      ")
+     ],
+     testTimeout: 300000,
+     typecheck: true,
+     threads: false
+   }
+ })
+ "@
+     
+     Set-Content -Path $tempConfigPath -Value $configContent
+     
+     # F√ºhre Vitest mit der tempor√§ren Konfiguration aus
+     npx vitest run --config $tempConfigPath --disable-console-intercept
+     
+     # Pr√ºfe den Exit-Code von Vitest
+     if ($LASTEXITCODE -eq 0) {
+         # L√∂sche die tempor√§re Konfiguration
+         Remove-Item -Path $tempConfigPath -Force
+         # Tests wurden erfolgreich ausgef√ºhrt
+         exit 0
+     } else {
+         # L√∂sche die tempor√§re Konfiguration
+         Remove-Item -Path $tempConfigPath -Force
+         Write-Host "Die .only Tests waren nicht erfolgreich, f√ºhre alle Tests aus..." -ForegroundColor Yellow
+     }
+ } else {
+     Write-Host "Keine .only Tests gefunden, f√ºhre alle Tests aus..." -ForegroundColor Yellow
+ }
+ 
+ # F√ºhre alle Tests aus
+ npx vitest --typecheck --coverage --watch=false --disable-console-intercept 
```

---

```diff
- 
+ # Coverage
+ 
+ Vitest unterst√ºtzt das Generieren von Code-Coverage-Berichten, um die Testabdeckung des Codes zu messen.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/coverage.html#coverage-setup](https://vitest.dev/guide/coverage.html#coverage-setup)
+ 
+ ## Konfiguration
+ 
+ Die Coverage-Konfiguration kann in der Vitest-Konfigurationsdatei vorgenommen werden:
+ 
+ ```typescript
+ export default defineConfig({
+     test: {
+         coverage: {
+             provider: 'v8', // oder 'istanbul'
+             include: ['src/'],
+             exclude: ['dist/'],
+             reporter: ['text', 'json', 'html']
+         }
+     }
+ })
+ ```
+ 
+ ## Ausf√ºhrung via Kommandozeile
+ 
+ Coverage kann auch √ºber die Kommandozeile aktiviert werden:
+ 
+ ```shell
+ vitest --coverage
+ ```
+ 
+ Das Flag kann auch mit einem Alias verwendet werden:
+ 
+ ```shell
+ vitest run --coverage
+ ``` 
```

---

Nun erstelle ich die Dateien f√ºr den API-Bereich:

---

```diff
- 
+ # API
+ 
+ Diese Seite enth√§lt Informationen zur API von Vitest und ihren Funktionen.
+ 
+ ## Inhaltsverzeichnis
+ - [Testing Types](./testing-types.md)
+ - [VI Utility](./vi-utility.md)
+ - [expectTypeOf](./expect-type-of.md)
+ - [expect](./expect.md) 
```

---

```diff
- 
+ # Testing Types
+ 
+ Vitest erm√∂glicht das Schreiben von Tests f√ºr Typen mit den Syntaxen `expectTypeOf` oder `assertType`. Standardm√§√üig werden alle Tests in `*.test-d.ts`-Dateien als Typ-Tests betrachtet, aber dies kann mit der Konfigurationsoption `typecheck.include` ge√§ndert werden.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/guide/testing-types](https://vitest.dev/guide/testing-types)
+ 
+ ## Konfiguration f√ºr regul√§re .test.ts-Dateien
+ 
+ Hier ist ein Beispiel, um alle `.test.ts`-Dateien statt nur `*.test-d.ts` f√ºr Typen-Tests zu verwenden. Es wird jedoch empfohlen, eigene Testdateien f√ºr Typpr√ºfungen zu erstellen, anstatt alles in einer einzigen Datei zu b√ºndeln.
+ 
+ ```typescript
+ import dotenv from 'dotenv'
+ // Load .env 
+ dotenv.config()
+ // Load .env.test and override .env
+ dotenv.config({ path: '.env.test', override: true })
+ 
+ // ==== DEPENDENCIES ====
+ import tsconfigPaths from 'vite-tsconfig-paths'
+ 
+ // ==== VITEST ====
+ import { defineConfig } from 'vitest/config'
+ 
+ /**
+  * Represents the configuration for the Vitest test runner.
+  */
+ export default defineConfig({
+     plugins: [tsconfigPaths()],
+     test: {
+         watch: false,
+         setupFiles: 'test/unit/pretestEach.ts',
+         globalSetup: 'test/integration/pretestAll.ts',
+         environment: 'node',
+         typecheck: {
+             include: ['**/*.{test,spec}.?(c|m)[jt]s?(x)'] // Hier den typecheck.include Wert einf√ºgen
+         },
+         coverage: {
+             /**
+              * Specifies the directories to include for coverage.
+              */
+             include: ['src/'],
+             /**
+              * Specifies the files or directories to exclude from coverage.
+              */
+             //exclude: ['src/legacy/', 'utils/helpers.ts'],
+             /**
+              * Specifies the coverage reporters to use.
+              */
+             reporter: ['text', 'json', 'html']
+         }
+     }
+ })
+ ```
+ 
+ ## Hintergrundfunktionsweise
+ 
+ Intern ruft Vitest `tsc` oder `vue-tsc` auf, abh√§ngig von der Konfiguration, und parst die Ergebnisse. Vitest gibt auch Typfehler im Quellcode aus, wenn welche gefunden werden. Dies kann mit der Konfigurationsoption `typecheck.ignoreSourceErrors` deaktiviert werden.
+ 
+ Beachten Sie, dass Vitest diese Dateien nicht ausf√ºhrt, sondern nur statisch vom Compiler analysieren l√§sst. Das bedeutet, dass wenn dynamische Namen, `test.each` oder `test.for` verwendet werden, der Testname nicht ausgewertet wird - er wird unver√§ndert angezeigt.
+ 
+ ## Aktivieren √ºber Kommandozeile
+ 
+ Um Typpr√ºfungen zu aktivieren, f√ºgen Sie einfach das Flag `--typecheck` zu Ihrem Vitest-Befehl in package.json hinzu:
+ 
+ ```json
+ {
+   "scripts": {
+     "test": "vitest --typecheck"
+   }
+ }
+ ``` 
```

---

```diff
- 
+ # VI Utility
+ 
+ Vitest stellt Hilfsfunktionen √ºber den `vi`-Helper bereit. Sie k√∂nnen darauf global zugreifen (wenn die `globals`-Konfiguration aktiviert ist) oder ihn direkt von Vitest importieren:
+ 
+ ```typescript
+ import { vi } from 'vitest'
+ ```
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/vi.html](https://vitest.dev/api/vi.html)
+ 
+ ## vi.stubEnv
+ 
+ √Ñndert den Wert einer Umgebungsvariable in `process.env` und `import.meta.env`. Sie k√∂nnen den urspr√ºnglichen Wert durch Aufruf von `vi.unstubAllEnvs` wiederherstellen.
+ 
+ ```typescript
+ import { vi } from 'vitest'
+ 
+ // `process.env.NODE_ENV` und `import.meta.env.NODE_ENV`
+ // sind "development" vor dem Aufruf von "vi.stubEnv"
+ 
+ vi.stubEnv('NODE_ENV', 'production')
+ 
+ process.env.NODE_ENV === 'production'
+ import.meta.env.NODE_ENV === 'production'
+ 
+ vi.stubEnv('NODE_ENV', undefined)
+ 
+ process.env.NODE_ENV === undefined
+ import.meta.env.NODE_ENV === undefined
+ 
+ // √§ndert keine anderen Umgebungsvariablen
+ import.meta.env.MODE === 'development'
+ ```
+ 
+ ## vi.unstubAllEnvs
+ 
+ Stellt alle `import.meta.env` und `process.env` Werte wieder her, die mit `vi.stubEnv` ge√§ndert wurden. Wenn es zum ersten Mal aufgerufen wird, merkt sich Vitest den Originalwert und speichert ihn, bis `unstubAllEnvs` erneut aufgerufen wird.
+ 
+ ```typescript
+ import { vi } from 'vitest'
+ 
+ // `process.env.NODE_ENV` und `import.meta.env.NODE_ENV`
+ // sind "development" vor dem Aufruf von "vi.stubEnv"
+ 
+ vi.stubEnv('NODE_ENV', 'production')
+ 
+ process.env.NODE_ENV === 'production'
+ import.meta.env.NODE_ENV === 'production'
+ 
+ vi.unstubAllEnvs()
+ 
+ // Werte werden auf die urspr√ºnglichen zur√ºckgesetzt
+ process.env.NODE_ENV === 'development'
+ import.meta.env.NODE_ENV === 'development'
+ ```
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/vi.html#vi-unstuballenvs](https://vitest.dev/api/vi.html#vi-unstuballenvs) 
```

---

```diff
- 
+ # expectTypeOf
+ 
+ Die `expectTypeOf`-Funktion wird verwendet, um Typen in TypeScript zu testen. Diese API erm√∂glicht es, die Typen von Funktionsparametern, R√ºckgabewerten und mehr zu √ºberpr√ºfen.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect-typeof](https://vitest.dev/api/expect-typeof)
+ 
+ ## Private Klassen-Konstruktoren
+ 
+ Es gibt keine direkte M√∂glichkeit, einen privaten Konstruktor auf Parametertypen zu testen. Eine L√∂sung ist, eine spezielle Testmethode zu erstellen:
+ 
+ ```typescript
+ class Foo {
+     private constructor(private x: number) {}
+ 
+     /** @internal */
+     static createForTesting(x: number) {
+         return new Foo(x);
+     }
+ }
+ 
+ const instance = Foo.createForTesting(5);
+ ```
+ 
+ Wenn Sie jedoch `getInstance` als Single-Method verwenden und dies der Grund ist, warum Ihr Konstruktor privat ist, k√∂nnen Sie diese Methode testen.
+ 
+ ## toEqualTypeOf
+ 
+ √úberpr√ºft, ob ein Typ einem anderen Typ entspricht:
+ 
+ ```typescript
+ expectTypeOf({ a: 1 }).toEqualTypeOf<{ a: number }>()
+ expectTypeOf({ a: 1 }).toEqualTypeOf({ a: 1 })
+ expectTypeOf({ a: 1 }).toEqualTypeOf({ a: 2 })
+ expectTypeOf({ a: 1, b: 1 }).not.toEqualTypeOf<{ a: number }>()
+ ```
+ 
+ ## Generics
+ 
+ Sie k√∂nnen auch Generic-Typen √ºberpr√ºfen:
+ 
+ ```typescript
+ expectTypeOf(modelManager.createModel<TMongooseSchema>).parameter(0).toEqualTypeOf<IModelCore<TMongooseSchema>>()
+ 
+ /**
+  * Creates a Mongoose model based on the given name, schema, and database name.
+  * @template TMongooseSchema - The type of the mongoose schema.
+  * @param modelDetails - An object containing the model's details.
+  * @returns A promise that resolves to the created Mongoose Model instance.
+  */
+ public async createModel<TMongooseSchema>({
+     modelName,
+     schema,
+     dbName
+ }: IModelCore<TMongooseSchema>): Promise< mongoose.Model<TMongooseSchema> > {
+     const mongooseUtils = await MongooseUtils.getInstance(dbName)
+     const Model = await mongooseUtils.createModel<TMongooseSchema>(schema, modelName)
+     
+     // Ensure indexes are created for the model
+     await Model.createIndexes()
+     return Model
+ }
+ ```
+ 
+ ## parameter
+ 
+ Extracts a parameter type from a function.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect-typeof.html#parameter](https://vitest.dev/api/expect-typeof.html#parameter)
+ 
+ ```typescript
+ expectTypeOf(modelManager['globModels']).parameter(0).toBeString()
+ expectTypeOf(modelManager.createModel<TMongooseSchema>).parameter(0).toEqualTypeOf<IModelCore<TMongooseSchema>>()
+ ```
+ 
+ **Hinweis**: Dies funktioniert nicht mit statischen Methoden in Klassen. Verwenden Sie stattdessen `.toBeCallableWith()`.
+ 
+ ## toBeCallableWith
+ 
+ √úberpr√ºft, ob eine Funktion mit bestimmten Parametern aufgerufen werden kann.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect-typeof.html#tobecallablewith](https://vitest.dev/api/expect-typeof.html#tobecallablewith)
+ 
+ ```typescript
+ expectTypeOf(ModelUtils.createMemoryModel).toBeCallableWith(modelCoreDetails)
+ ```
+ 
+ ## returns
+ 
+ Extrahiert den R√ºckgabewert eines Funktionstyps.
+ 
+ ```typescript
+ import { expectTypeOf } from 'vitest'
+ 
+ expectTypeOf(() => {}).returns.toBeVoid()
+ expectTypeOf((a: number) => [a, a]).returns.toEqualTypeOf([1, 2])
+ expectTypeOf(modelManager['getModels']).returns.toEqualTypeOf<IModel<mongoose.SchemaDefinition<{}>>[]>()
+ 
+ // Bei Bedarf k√∂nnen Sie ein Promise selbst aufrufen und mit returns √ºberpr√ºfen,
+ // aber es wird empfohlen, resolve zu verwenden
+ expectTypeOf(ModelManager.getInstance).returns.toEqualTypeOf(Promise.resolve(modelManager))
+ ```
+ 
+ ## resolve
+ 
+ Extrahiert den aufgel√∂sten Wert eines Promise, sodass Sie weitere Assertions daran durchf√ºhren k√∂nnen.
+ 
+ ```typescript
+ import { expectTypeOf } from 'vitest'
+ 
+ async function asyncFunc() {
+   return 123
+ }
+ 
+ expectTypeOf(asyncFunc).returns.resolves.toBeNumber()
+ expectTypeOf(Promise.resolve('string')).resolves.toBeString()
+ 
+ // WEITERE BEISPIELE
+ expectTypeOf(ModelManager.getInstance).returns.resolves.toEqualTypeOf<ModelManager>()
+ 
+ // Private Klassenmethoden
+ expectTypeOf(modelManager['globModels']).returns.resolves.toEqualTypeOf<IModel<mongoose.SchemaDefinition<{}>>[]>()
+ expectTypeOf(modelManager['init']).returns.resolves.toBeVoid()
+ ```
+ 
+ ## instance
+ 
+ Erm√∂glicht den Zugriff auf Matcher, die an einer Instanz der bereitgestellten Klasse durchgef√ºhrt werden k√∂nnen.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect-typeof#instance](https://vitest.dev/api/expect-typeof#instance)
+ 
+ ```typescript
+ import { expectTypeOf } from 'vitest'
+ 
+ expectTypeOf(Date).instance.toHaveProperty('toISOString')
+ ``` 
```

---

```diff
- 
+ # expect
+ 
+ Die `expect`-Funktion in Vitest wird verwendet, um Assertions in Tests durchzuf√ºhren.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html)
+ 
+ ## objectContaining
+ 
+ Pr√ºft, ob ein Objekt bestimmte Eigenschaften enth√§lt.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect.html#expect-objectcontaining](https://vitest.dev/api/expect.html#expect-objectcontaining)
+ 
+ ```javascript
+ import { expect, test } from 'vitest'
+ 
+ // Beispiel #1
+ expect(chatCompletion).toEqual(expect.objectContaining(expectedResponse))
+ 
+ // Beispiel #2
+ test('basket has empire apples', () => {
+   const basket = {
+     varieties: [
+       {
+         name: 'Empire',
+         count: 1,
+       }
+     ],
+   }
+   expect(basket).toEqual({
+     varieties: [
+       expect.objectContaining({ name: 'Empire' }),
+     ]
+   })
+ })
+ ```
+ 
+ ## toThrowError()
+ 
+ Pr√ºft, ob eine Funktion einen Fehler wirft.
+ 
+ Offizielle Dokumentation: [https://vitest.dev/api/expect.html#tothrowerror](https://vitest.dev/api/expect.html#tothrowerror)
+ 
+ ### Synchrone Funktionen
+ 
+ ```javascript
+ import { expect, test } from 'vitest'
+ 
+ function getFruitStock(type: string) {
+   if (type === 'pineapples') {
+     throw new Error('Pineapples are not in stock')
+   }
+ 
+   // Do some other stuff
+ }
+ 
+ test('throws on pineapples', () => {
+   // Test that the error message says "stock" somewhere: these are equivalent
+   expect(() => getFruitStock('pineapples')).toThrowError(/stock/)
+   expect(() => getFruitStock('pineapples')).toThrowError('stock')
+ 
+   // Test the exact error message
+   expect(() => getFruitStock('pineapples')).toThrowError(
+     /^Pineapples are not in stock$/,
+   )
+ })
+ ```
+ 
+ ### Asynchrone Funktionen
+ 
+ ```javascript
+ function getAsyncFruitStock() {
+   return Promise.reject(new Error('empty'))
+ }
+ 
+ test('throws on pineapples', async () => {
+   await expect(() => getAsyncFruitStock()).rejects.toThrowError('empty')
+ })
+ ``` 
```

---

Jetzt erstelle ich die neue README.md-Datei mit dem Inhaltsverzeichnis, die auf die index.md-Dateien in den Hauptordnern verlinkt:

---

```diff
- 
+  
```

---

Scheint ein Problem gegeben zu haben. Lasse uns die Datei erneut erstellen:

---

```diff
-  
+ # Vitest Cheat Sheet
+ 
+ Eine umfassende Sammlung von Tipps, Konfigurationen und Best Practices f√ºr die Verwendung von Vitest als Test-Framework.
+ 
+ ## Inhaltsverzeichnis
+ 
+ 1. [Installation](./installation/index.md)
+    - [Next.js](./installation/nextjs.md)
+ 
+ 2. [CLI](./cli/index.md)
+    - [Enable console.log](./cli/enable-console-log.md)
+    - [Disable watch](./cli/disable-watch.md)
+    - [Timeout](./cli/timeout.md)
+ 
+ 3. [Konfiguration](./configuration/index.md)
+    - [vitest.config.ts](./configuration/vitest-config-ts.md)
+    - [vitest.unit.config.ts](./configuration/vitest-unit-config-ts.md)
+    - [vitest.integration.config.ts](./configuration/vitest-integration-config-ts.md)
+    - [setupFiles](./configuration/setup-files.md)
+    - [globalSetup](./configuration/global-setup.md)
+    - [watch](./configuration/watch.md)
+ 
+ 4. [Snapshots](./snapshots/index.md)
+ 
+ 5. [Tests](./tests/index.md)
+    - [Test Environment](./tests/test-environment.md)
+    - [Nested Tests](./tests/nested-tests.md)
+    - [Test Filtering](./tests/test-filtering.md)
+    - [Coverage](./tests/coverage.md)
+ 
+ 6. [API](./api/index.md)
+    - [Testing Types](./api/testing-types.md)
+    - [VI Utility](./api/vi-utility.md)
+    - [expectTypeOf](./api/expect-type-of.md)
+    - [expect](./api/expect.md) 
```

---

Erstelle jetzt die `index.md`-Dateien in den Hauptordnern:

---

```bash
mv README.md README.md.original
```

```
‚ï∞‚îÄ> mv README.md README.md.original

‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main „Äò‚ùåÔøΩ„Äô
‚ï∞‚îÄ>
```

---

```bash
mv README.md.new README.md
```

```
‚ï∞‚îÄ> mv README.md.new README.md

‚ï≠‚îÄdenni@MININT-A8821UQ ‚ü∂  vitest-cheat-sheet on ÓÇ† main „ÄòÔøΩÔøΩ„Äô
‚ï∞‚îÄ>
```

---

√úberpr√ºfen wir abschlie√üend die Verzeichnisstruktur, um sicherzustellen, dass alles korrekt erstellt wurde:

---

<details>
            <summary>Listed current directory ‚Ä¢ **9** results</summary>
        
| Name |
|-------|
| üìÑ `README.md` |
| üìÅ `api` |
| üìÅ `tests` |
| üìÅ `snapshots` |
| üìÅ `configuration` |
| üìÅ `cli` |
| üìÅ `installation` |
| üìÅ `.git` |
| üìÑ `README.md.original` |

</details>

---

<details>
            <summary>Listed directory installation ‚Ä¢ **2** results</summary>
        
| Name |
|-------|
| üìÑ `nextjs.md` |
| üìÑ `index.md` |

</details>

---

<details>
            <summary>Listed directory cli ‚Ä¢ **4** results</summary>
        
| Name |
|-------|
| üìÑ `timeout.md` |
| üìÑ `disable-watch.md` |
| üìÑ `enable-console-log.md` |
| üìÑ `index.md` |

</details>

---

<details>
            <summary>Listed directory configuration ‚Ä¢ **7** results</summary>
        
| Name |
|-------|
| üìÑ `watch.md` |
| üìÑ `global-setup.md` |
| üìÑ `setup-files.md` |
| üìÑ `vitest-integration-config-ts.md` |
| üìÑ `vitest-unit-config-ts.md` |
| üìÑ `vitest-config-ts.md` |
| üìÑ `index.md` |

</details>

---

<details>
            <summary>Listed directory snapshots ‚Ä¢ **1** results</summary>
        
| Name |
|-------|
| üìÑ `index.md` |

</details>

---

<details>
            <summary>Listed directory tests ‚Ä¢ **5** results</summary>
        
| Name |
|-------|
| üìÑ `coverage.md` |
| üìÑ `test-filtering.md` |
| üìÑ `nested-tests.md` |
| üìÑ `test-environment.md` |
| üìÑ `index.md` |

</details>

---

<details>
            <summary>Listed directory api ‚Ä¢ **5** results</summary>
        
| Name |
|-------|
| üìÑ `expect.md` |
| üìÑ `expect-type-of.md` |
| üìÑ `vi-utility.md` |
| üìÑ `testing-types.md` |
| üìÑ `index.md` |

</details>

---

# Zusammenfassung der Modularisierung

Die Dokumentation wurde erfolgreich in eine modulare Ordnerstruktur aufgeteilt. Hier ist eine √úbersicht der durchgef√ºhrten Schritte:

1. Analyse der urspr√ºnglichen README.md-Datei und Erstellung eines detaillierten Inhaltsverzeichnisses (TOC).
2. Entwurf einer neuen Ordnerstruktur basierend auf dem TOC.
3. Erstellung der Hauptverzeichnisse:
   - installation
   - cli
   - configuration
   - snapshots
   - tests
   - api

4. Extrahierung und Aufteilung des Inhalts der urspr√ºnglichen README.md in einzelne Markdown-Dateien:
   - F√ºr jedes Verzeichnis wurde eine `index.md`-Datei erstellt, die als √úbersicht dient.
   - Die Unterabschnitte wurden in separate Markdown-Dateien aufgeteilt.

5. Erstellung einer neuen README.md im Wurzelverzeichnis als zentraler Einstiegspunkt mit Links zu allen Abschnitten.

Die neue Struktur erm√∂glicht eine bessere Navigation und √úbersicht √ºber die Dokumentation, w√§hrend gleichzeitig der gesamte Inhalt der urspr√ºnglichen README.md beibehalten wurde. Die urspr√ºngliche README.md wurde als `README.md.original` gesichert.

---

_**User**_

perfekt aber im cli ordner kann alles in eine einzelne mark,down datei

---

_**Assistant**_

Ich werde die Dateien im CLI-Ordner in eine einzelne Markdown-Datei zusammenf√ºhren.

---

```diff
  Diese Seite enth√§lt Informationen zur Verwendung der Vitest Command Line Interface.
  
- ## Inhaltsverzeichnis
- - [Enable console.log](./enable-console-log.md)
- - [Disable watch](./disable-watch.md)
- - [Timeout](./timeout.md)
+ ## Enable console.log
+ 
+ Um die automatische Unterdr√ºckung der Konsolenausgabe zu deaktivieren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --disable-console-intercept
+ ```
+ 
+ Dies erlaubt die Anzeige von Ausgaben √ºber `console.log` w√§hrend der Testausf√ºhrung.
+ 
+ ## Disable watch
+ 
+ Um den Watch-Modus zu deaktivieren und die Tests nur einmal auszuf√ºhren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --watch=false
+ ```
+ 
+ Alternative Option:
+ 
+ ```shell
+ --run
+ ```
+ 
+ ## Timeout
+ 
+ Um ein individuelles Timeout f√ºr Tests zu definieren, kann der folgende Parameter verwendet werden:
+ 
+ ```shell
+ --testTimeout=5000
+ ```
+ 
+ Der Wert wird in Millisekunden angegeben. Der Standardwert ist 5000ms (5 Sekunden).
  
  ## Verf√ºgbare CLI-Optionen
```

---

Jetzt muss ich die einzelnen Dateien im CLI-Ordner l√∂schen, da diese nun in die index.md integriert wurden:

---

L√∂sche die nicht mehr ben√∂tigte enable-console-log.md, da der Inhalt in index.md integriert wurde.

---

L√∂sche die nicht mehr ben√∂tigte disable-watch.md, da der Inhalt in index.md integriert wurde.

---

L√∂sche die nicht mehr ben√∂tigte timeout.md, da der Inhalt in index.md integriert wurde.

---

```diff
  
  2. [CLI](./cli/index.md)
-    - [Enable console.log](./cli/enable-console-log.md)
-    - [Disable watch](./cli/disable-watch.md)
-    - [Timeout](./cli/timeout.md)
+    - [Enable console.log](./cli/index.md#enable-consolelog)
+    - [Disable watch](./cli/index.md#disable-watch)
+    - [Timeout](./cli/index.md#timeout)
  
  3. [Konfiguration](./configuration/index.md)
```

---

Ich habe erfolgreich alle CLI-Dateien in eine einzelne Markdown-Datei zusammengef√ºhrt und die Links in der README.md entsprechend aktualisiert.

Die separate Dateien `enable-console-log.md`, `disable-watch.md` und `timeout.md` wurden gel√∂scht, und ihr Inhalt wurde direkt in die `index.md` des CLI-Ordners integriert.

Die README.md wurde so aktualisiert, dass die Links zu den CLI-Themen nun direkt auf die entsprechenden Abschnitte in der zusammengef√ºhrten Datei verweisen.

---



---

